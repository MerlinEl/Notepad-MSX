//**************************************************************************************************************************//
//                                                                                                                          //
//    Photoshop DDS export tools                                                                                            //
//      -main functions                                                                                                     //
//                                                                                                                          //
//    Jiri Bicik                                                                                                            //
//    2K Czech @2012                                                                                                        //
//                                                                                                                          //
//**************************************************************************************************************************//

#target photoshop

#include "Log_Functions.jsx"
#include "Wip_Dialog.jsx"

// ------------------------------------------------------------------------------------------------------------------------ //
const C_BUILD_DEBUG = false;             // Set this is you want to run commandline scripts from debugger //
// ------------------------------------------------------------------------------------------------------------------------ //
const C_CLEAR_LOG = false;              // set this to true if you want to clear log file for each run
const C_DELETE_TEMP_FILES = true;       // set this to false if you want to keep all textures
const C_DELETE_TEMP_COMMAND = true;     // set this to false if you want to keep all temporary command files
const C_SCRIPT_VERSION = "3.90";        // CHANGE THIS AFTER YOU MAKE SOME CHANGES
// ------------------------------------------------------------------------------------------------------------------------ //
const C_REG_QUERY = "QUERY \"HKCU\\Software\\Illusion Softworks\\LS3D.GUP_2011\\Client Settings\" /v ";
const C_ENVVAR_RESOURCES = "ResourcesPath";
const C_ENVVAR_ENGINE = "EnginePath";
const C_ENVVAR_UTILS = "UtilsPath";
const C_ENVVAR_EDITOR = "EditorPath";
const C_CONFIG_FILE = "..\\photoshop\\texture_formats_config.xml";
const C_MATERIAL_TEMPLATES_CONFIG_FILE = "..\\photoshop\\material_templates_config.xml";
//const C_LIBRARY_NAME = "ClassLibrary3";
//const C_LIBRARY_PATH = "lib:c:\\users\\jbicik\\documents\\visual studio 2012\\Projects\\ClassLibrary3\\x64\\Debug\\" + C_LIBRARY_NAME;
const C_RESOLUTIONS = Array("unchanged", 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384);
const C_MIPMAPS = Array("all", "none", 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14);
const C_SCALES = Array("1x", "1/16x", "1/8x", "1/4x", "1/2x", "1x", "2x", "4x");
const C_NUMERIC_SCALES = Array(1, 0.0625, 0.125, 0.25, 0.5, 1, 2, 4);
const C_SCALE_FILTER = Array("box", "triangle", "quadratic", "bspline", "mitchell", "lanczos", "kaiser");
const C_QUALITY = Array("quality_normal", "quality_production", "quality_highest", "quick");
const C_SHARPENING = Array("None", "Negative", "Lighter", "Darker", "ContrastMore", "ContrastLess", "Smoothen", "SharpenSoft", "SharpenMedium", "SharpenStrong", "FindEdges", "Contour", "EdgeDetect", "EdgeDetectSoft", "Emboss", "MeanRemoval");
const C_RESIZE_FILTER = Array("BICUBIC SHARP", "NEAREST NEIGHBOR", "BILINEAR", "BICUBIC", "BICUBIC SMOOTH");
const C_DXT_FORMATS = Array("BC1 - DXT1", "BC1a - DXT1a", "BC2 - DXT3", "BC3 - DXT5", "BC4", "BC5", "BC6", "BC7", "R8G8B8A8");
const C_NORMALMAP_NAMES = Array("normal1", "normal5");

// When adding another compressor, you have to modify:
// texture_formats_config.xml   - paths to compression tools
// ReadGlobalConfig() and ExportersInstalationTest()        - reading paths from xml
// LS3DCompressorParams()       - list of parameters that are used by compressors
// GetCompressorPaths()         - store correct compression paths based on selected compressor
// app.C_SELECTED_COMPRESSOR_INDEX      - select which compressor is used
// PickExternalCompressor()     - call correct compressor 
// CF_SOMENAME()          - Compress Function that generates correct command line based on compressor .exe requirements
// any other function that you need to get correct command line (usually formats)
const C_COMPRESSORS = Array("DDSUtils", "TexTools2", "TexConv");

const C_F_DEFAULT_DDSFORMAT = 0;
const C_F_DEFAULT_SCALE = 5;
const C_F_DEFAULT_SCALE_FILTER = 6;
const C_F_DEFAULT_RESOLUTION = 0;
const C_F_DEFAULT_CUBEMAP = false;
const C_F_DEFAULT_MIPMAPS = 0;
const C_F_DEFAULT_QUALITY = 0;
const C_F_DEFAULT_SHARPENING = 7;
const C_F_DEFAULT_RESIZE_FILTER = 0;
const C_F_DEFAULT_CUSTOMMIPMAPS = false;
const C_TEMP_FORMAT_TYPE = "TGA";
const C_READ_ENGINE_PATH_SLEEP = 500;
const C_READ_ENGINE_PATH_SLEEP_BACKUP = 2000;

//const C_INPUT_TYPES = Array("DDS_EXPORT_1", "DDS_EXPORT_2");
//const C_DDS_EXPORT_RESULTS = Array("OK_ALL_OK", "E_UNKNOWN_ERROR", "E_MISSING_FILE", "E_WRITE_PROTECT");




//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------- DATA TYPES ----------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function MaterialTemplateMapType(newEngineVar, newTypeName, newDefault)
    {
        this.engineVariable = newEngineVar;
        this.mapTypeName = newTypeName;
        this.defaultTexture = newDefault;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function MaterialTemplate(newName, newGuid, newMapTypes)
    {
        this.name = newName;
        this.guid = newGuid;
        this.mapTypes = newMapTypes;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function MaterialTemplateList()
    {
        this.list = new Array();
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GroupType(newName)
    {
        this.name = newName;
        this.description = "%MISSING STRING%";
        this.strings = new Array();
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ChannelType(myGroup, myChannel, myColor)
    {
        this.group = myGroup;
        this.channel = myChannel;
        this.color = myColor;
    }
    

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Format() {
        this.disabled = -1;
        this.name = "";
        this.ddsFormat = C_F_DEFAULT_DDSFORMAT;
        this.resolutionX = C_F_DEFAULT_RESOLUTION;
        this.resolutionY = C_F_DEFAULT_RESOLUTION;
        this.scale = C_F_DEFAULT_SCALE;
        this.scaleFilter = C_F_DEFAULT_SCALE_FILTER;
        this.cubemap = C_F_DEFAULT_CUBEMAP;
        this.mipmaps = C_F_DEFAULT_MIPMAPS;
        this.quality = C_F_DEFAULT_QUALITY;
        this.sharpening = C_F_DEFAULT_SHARPENING;
        this.customMipmaps = C_F_DEFAULT_CUSTOMMIPMAPS;
        this.filter = C_F_DEFAULT_RESIZE_FILTER;
        this.variance = false;
        this.requires = new Array();
        this.force_compressor = -1;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function MapType(newName)
    {
        this.enabled = true;
        this.name = newName;
        this.red = null;
        this.green = null;
        this.blue = null;
        this.alpha = null;
        this.formats = new Array();
        this.suffix = "";
        this.defaults = null;
        this.force_compressor = -1;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LS3DDdsExportData() {
        this.groupTypes = new Array();
        this.mapTypes = new Array();
    }
    

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LS3DCustomData() {
        this.version = "";
        this.exportPath = "";
        this.enginePath = "";
        this.utilsPath = "";
        this.editorPath = "";
        this.customExportPath = false;
        this.profile = "";
        this.formats = new Array();
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function UserGroupList() {
        this.name = "";
        this.groupNames = new Array();
    }    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LS3DUserGroupTypes() {
        this.userGroupList = new Array();
    }    

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function UserMapList() {
        this.name = "";
        this.nodds = false;
        this.mapNames = new Array();
    }    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LS3DUserMapTypes() {
        this.userMapList = new Array();
    }    
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LS3DCompressorParams() {
        this.compressorName = "";
        this.compressorPath = "";
        this.scalePath = "";
        this.assemblePath = "";
        this.inPath = "";
        this.inFile = "";
        this.inType = "";
        this.outPath = "";
        this.outFile = "";
        this.outType = "";
        this.width = 0;
        this.height = 0;
        this.mipCount = 0;
        this.format = "";
        this.filter = 0;               // not used: filter for compressor side resizing
        this.customMips = false;
        this.cubemap = false;
        this.isNormalMap = false;
        this.hasAlpha = false;
        this.requires = new Array();
        this.force_compressor = -1;
        this.nodds = false;
        this.Copy = function () {   // Self copy function
            var result = new LS3DCompressorParams();
            result.compressorName = this.compressorName;
            result.compressorPath = this.compressorPath;            
            result.scalePath = this.scalePath;            
            result.assemblePath = this.assemblePath;            
            result.inPath = this.inPath;            
            result.inFile = this.inFile;            
            result.inType = this.inType;            
            result.outPath = this.outPath;            
            result.outFile = this.outFile;            
            result.outType = this.outType;            
            result.width = this.width;            
            result.height = this.height;            
            result.mipCount = this.mipCount;            
            result.format = this.format;            
            result.filter = this.filter;            
            result.customMips = this.customMips;            
            result.cubemap = this.cubemap;            
            result.isNormalMap = this.isNormalMap;
            result.hasAlpha = this.hasAlpha;
            result.requires = this.requires;
            result.force_compressor = this.force_compressor;
            result.nodds = this.nodds;
            return result;
        }
    }
}
//------- /END DATA TYPES ----------------------------------------------------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------- PSD Helper functions ----------------------------------------------------------------------------------------------------------------------------------------------
{
    // Returns the top most layer of the document tree from the specified layer
    function FindTopMostLayer(layer)
    {
        var tmplayer = layer;
        while (tmplayer.parent.typename != "Document")
        {
            tmplayer = tmplayer.parent;
        }
        return tmplayer;
    }
}

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------- LS3D DATA FUNCTIONS ----------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    function CacheNames(layerArray)
    {
        UpdateWipDialog(1, "Caching layers" + layerArray, false);
        var result = new Array();
        var name = "";
        for (i = 0; i < layerArray.length; i++) {
            name = layerArray[i].name.toLowerCase();
            UpdateWipDialog(1, "Caching layer names " + name, false);
            result.push(name);
        }
        return result;
    }
   
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FindGroupTypeIDByType(groupType)
    {
        log("START: FindGroupTypeIDByType(groupType: " + groupType + ")", 1, 3);
        var selectedGroupID = -1;
        for (i = 0; i < app.ls3dDdsExportData.groupTypes.length; i++) {
            var type = app.ls3dDdsExportData.groupTypes[i];
//            log(type.name, 1, 4);
            if (type.name == groupType) selectedGroupID = i;
        }            
        log("END: FindGroupTypeIDByType() = " + selectedGroupID, 1, 3);        
        return selectedGroupID;
    }    
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FindGroupTypeIDByName(groupName)
    {
        log("START: FindGroupTypeIDByName(" + groupName + ")", 1, 3);
        var selectedGroupID = -1;
        for (i = 0; i < app.ls3dDdsExportData.groupTypes.length; i++) {
            var type = app.ls3dDdsExportData.groupTypes[i];
            
            // HOT Fix to be able to export roughness layer 
            // --
            // if (type.strings[0] == groupName.toLowerCase()) {   //  used with previous FixGroupNames() 
                // selectedGroupID = i;
            // }
            
            for (j = 0; j < type.strings.length; j++) {
                if (type.strings[j] == groupName.toLowerCase()) selectedGroupID = i;
            }
            // --

        }
        
        log("END: FindGroupTypeIDByName() = " + selectedGroupID, 1, 3);
        return selectedGroupID;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FindCollapsedLayerByType(groupType, document)
    {
        log("START: FindCollapsedLayerByType(groupType: " + groupType.strings[0] + ", " + document + ")", 1, 3);
        var selectedLayer = null;
        var name = "";
        if (app.CACHE_CollapsedArtLayerNames == null) {
            app.CACHE_CollapsedArtLayerNames = CacheNames(document.artLayers);
        }
        for (i = 0; i < app.CACHE_CollapsedArtLayerNames.length; i++) {            
            name = app.CACHE_CollapsedArtLayerNames[i];
            if (groupType.strings[0] == name) selectedLayer = document.artLayers[i];
/*            for (j = 0; j < groupType.strings.length; j++) {      // this shouldn't be necessary after FixGroupNames()
                if (groupType.strings[j] == name) selectedLayer = document.artLayers[i];
            }                */
        }            
        log("END: FindCollapsedLayerByType() = " + selectedLayer, 1, 3);
        return selectedLayer;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FindMapTypeIDByGroupID(groupID)
    {
        var groupName = app.ls3dDdsExportData.groupTypes[groupID].name;
        var mapTypes = app.ls3dDdsExportData.mapTypes;
        log("FindMapTypeIDByGroupID: groupName: " + groupName + " mapTypes: " + mapTypes, 1, 3);
        var mapIDs = new Array();
        for (var i = 0; i < mapTypes.length; i++) {
            var tempMapID = -1;
            if ((mapTypes[i].red != null) && (mapTypes[i].red.group == groupName))          { tempMapID = i; }
            if ((mapTypes[i].green != null) && (mapTypes[i].green.group == groupName))   { tempMapID = i; }
            if ((mapTypes[i].blue != null) && (mapTypes[i].blue.group == groupName))        { tempMapID = i; }
            if ((mapTypes[i].alpha != null) && (mapTypes[i].alpha.group == groupName))      { tempMapID = i; }            
            if (tempMapID != -1) { mapIDs.push(tempMapID); }
            log("FindMapTypeIDByGroupID: tempMapID[" + i + "] = " + tempMapID, 1, 3);
            if (app.ls3DCustomData.formats.length > i) { 
                log("FindMapTypeIDByGroupID: format.name = " + app.ls3DCustomData.formats[i].name + "   mapTypes.name = " +  mapTypes[i].name, 1, 3); }
            else {
                log("FindMapTypeIDByGroupID: invalid format index. Resave in UI needed.   mapTypes.name = " +  mapTypes[i].name, 2, 2); }
        }
        return mapIDs;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FindGroupsByMapTypeID(mapTypeID)
    {
        var result = new Array();
        var mapTypes = app.ls3dDdsExportData.mapTypes;
        var mapType = mapTypes[mapTypeID];
        if (mapType.red != null) result.push(mapType.red.group);
        if (mapType.green != null) result.push(mapType.green.group);
        if (mapType.blue != null) result.push(mapType.blue.group);
        if (mapType.alpha != null) result.push(mapType.alpha.group);
        log("FindGroupIDsByMapTypeID: mapTypeID: " + mapTypeID + " mapType: " + mapType, 1, 3);
        log("FindGroupIDsByMapTypeID = " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FindMapIDByName(mapName)
    {
        var mapTypes = app.ls3dDdsExportData.mapTypes;
        for (var i = 0; i < mapTypes.length; i++) {
            if (mapTypes[i].name == mapName) return i
        }
        return -1;
    }
}

//------- /END LS3D DATA FUNCTIONS ----------------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//------- CUSTOM ATTRIBUTES FUNCTIONS ----------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function StringToNumber(input)
    {
        var result = parseFloat(input);
        if (result = NaN) { result = 0; }
        return result;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetProfileIndexByName(name)
    {
        if ((app.ls3dUserMapTypes != null) && (app.ls3dUserMapTypes.userMapList != null)) {
            for (var i = 0; i < app.ls3dUserMapTypes.userMapList.length; i++) {
                if (app.ls3dUserMapTypes.userMapList[i].name == name) return i;
            }
        } else return -1;
        return 0;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SaveDocumentInfo(info)
    {
        app.activeDocument.info.caption = info;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LoadDocumentInfo()
    {
        return app.activeDocument.info.caption;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LoadDebugMode()
    {
        log("START: LoadDebugMode()", 1, 3);
        var customData = new XML(LoadDocumentInfo());        
        app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS = (customData.child('DebugMode').toString() == "true");
        app.C_DEBUG_FLIP_NORMAL = (customData.child('FlipNormal').toString() == "true");
        log("END: LoadDebugMode()", 1, 3);
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadFormat(xmlFile)
    {
        var newFormat = new Format();
        newFormat.name = (xmlFile.@name).toString();

        var disabled = xmlFile.disabled.toString();
        if (disabled == "") {
            var name = newFormat.name;
            if ((name == "diffuse") || (name == "diffuse 2uv") || (name == "glossiness") || (name == "normal1") ||
                (name == "normal5") || (name == "emissive") || (name == "height") || (name == "subsurface") ||
                (name == "detail mask") || (name == "masks map") || (name == "color zones") || (name == "car dirt and rust") ||
                (name == "car burned") || (name == "particle diffuse") || (name == "particle diffuse alpha")) { disabled = "0"; }
            else { disabled = "1"; }
        }
        newFormat.disabled = Number(disabled);
        newFormat.ddsFormat = Number(xmlFile.ddsFormat.toString());
        newFormat.resolutionX = Number(xmlFile.resolutionX.toString());
        newFormat.resolutionY = Number(xmlFile.resolutionY.toString());
        newFormat.scale = Number(xmlFile.scale.toString());
        newFormat.scaleFilter = Number(xmlFile.scaleFilter.toString());
        newFormat.cubemap = (xmlFile.cubemap.toString() == "true");
        newFormat.mipmaps = Number(xmlFile.mipmaps.toString());
        newFormat.quality = Number(xmlFile.quality.toString());
        newFormat.sharpening = Number(xmlFile.sharpening.toString());
        newFormat.filter = Number(xmlFile.filter.toString());
        newFormat.customMipmaps = (xmlFile.customMipmaps.toString() == "true");
        app.ls3DCustomData.formats.push(newFormat);
        return true;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LoadCustomAttribs()
    {
        var customData = new XML(LoadDocumentInfo());
        log("Loaded CustomAttribs:\n" + customData, 1, 4);
        app.ls3DCustomData.exportPath = customData.child('ExportPath').toString();
        app.ls3DCustomData.version = customData.child('Version').toString();
        app.ls3DCustomData.profile = customData.child('Profile').toString();
        app.ls3DCustomData.customExportPath = (customData.child('CustomExportPath').toString() == "true");
        var formats = customData.child("formats");
        for (i = 0; i < formats.elements().length(); i++) {
            var format = formats.format[i];
            ReadFormat(format);
        }            
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SaveCustomAttribs()
    {
        var customData = "<LS3DCustomAttributes>\n";
        customData += "<Version>" + C_SCRIPT_VERSION.toString() + "</Version>\n";
        customData += "<ExportPath>" + app.ls3DCustomData.exportPath + "</ExportPath>\n";
        customData += "<CustomExportPath>" + app.ls3DCustomData.customExportPath.toString() + "</CustomExportPath>\n";
        customData += "<Profile>" + app.ls3DCustomData.profile.toString() + "</Profile>\n";
        customData += "\t<formats>\n";
        var formats = app.ls3DCustomData.formats;
        for (i = 0; i < formats.length; i++) {
            if (formats[i].name != "") {
                customData += "\t\t<format name = \"" + formats[i].name + "\">\n";
                if (formats[i].disabled == -1) { formats[i].disabled = 1; }
                customData += "\t\t\t<disabled>" + formats[i].disabled + "</disabled>\n";
                customData += "\t\t\t<ddsFormat>" + formats[i].ddsFormat + "</ddsFormat>\n";
                customData += "\t\t\t<resolutionX>" + formats[i].resolutionX + "</resolutionX>\n";
                customData += "\t\t\t<resolutionY>" + formats[i].resolutionY + "</resolutionY>\n";
                customData += "\t\t\t<scale>" + formats[i].scale + "</scale>\n";
                customData += "\t\t\t<scaleFilter>" + formats[i].scaleFilter + "</scaleFilter>\n";
                customData += "\t\t\t<cubemap>" + formats[i].cubemap + "</cubemap>\n";
                customData += "\t\t\t<mipmaps>" + formats[i].mipmaps + "</mipmaps>\n";
                customData += "\t\t\t<quality>" + formats[i].quality + "</quality>\n";
                customData += "\t\t\t<sharpening>" + formats[i].sharpening + "</sharpening>\n";
                customData += "\t\t\t<filter>" + formats[i].filter + "</filter>\n";
                customData += "\t\t\t<customMipmaps>" + formats[i].customMipmaps + "</customMipmaps>\n";
                customData += "\t\t</format>\n";
            }
        }
        customData += "\t</formats>\n";
        customData += "<DebugMode>" + app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS + "</DebugMode>\n";
        customData += "<FlipNormal>" + app.C_DEBUG_FLIP_NORMAL + "</FlipNormal>\n";
        customData += "</LS3DCustomAttributes>";
        log("CustomAttribs to save:\n" + customData, 1, 3);
        SaveDocumentInfo(customData);
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CustomAttribsExist()
    {
        var temp = LoadDocumentInfo();
        return (temp != "")
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SwapElements(i, j)
    {
        var temp = app.ls3DCustomData.formats[i];
        app.ls3DCustomData.formats[i] = app.ls3DCustomData.formats[j]; 
        app.ls3DCustomData.formats[j] = temp;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SortFormatsAndMapTypes()
    {
        var result = true;
        for (var i = 0; i < app.ls3dDdsExportData.mapTypes.length; i++ ) {
            if (i < app.ls3DCustomData.formats.length) {
                if (app.ls3dDdsExportData.mapTypes[i].name != app.ls3DCustomData.formats[i].name) {
                    result = false;
                    for (j = 0; j < app.ls3DCustomData.formats.length; j++) {
                        if (app.ls3DCustomData.formats[j].name == app.ls3dDdsExportData.mapTypes[i].name) {
                            //log("swap " + i + " , " + j, 1, 4)
                            SwapElements(i, j);
                        }
                    }                    
                }
            }
        }
        return result;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetDefaultFormat(name)
    {
        var newFormat = new Format();          
        var mapID = FindMapIDByName(name)
        if (mapID > -1) {
            var mapDefault = app.ls3dDdsExportData.mapTypes[mapID].defaults;
            newFormat.name = name;
            newFormat.ddsFormat         = mapDefault.ddsFormat;
            newFormat.resolutionX       = mapDefault.resolutionX;
            newFormat.resolutionY       = mapDefault.resolutionY;
            newFormat.scale             = mapDefault.scale;
            newFormat.scaleFilter       = mapDefault.scaleFilter;
            newFormat.cubemap           = mapDefault.cubemap;
            newFormat.mipmaps           = mapDefault.mipmaps;
            newFormat.quality           = mapDefault.quality;
            newFormat.sharpening        = mapDefault.sharpening;
            newFormat.filter            = mapDefault.filter;
            newFormat.cunstomMipmaps    = mapDefault.cunstomMipmaps;
        }
        return newFormat;
    }
}
//------- /END CUSTOM ATTRIBUTES FUNCTIONS ----------------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- LOAD CONFIG --------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LoadSystemPathsFromEnvVariables()
    {
        log("START: LoadSystemPathsFromEnvVariables()", 1, 3);
        var result = true;
        var envVarUtils = $.getenv(C_ENVVAR_UTILS);
        var envVarEngine = $.getenv(C_ENVVAR_ENGINE);
        var envVarResources = $.getenv(C_ENVVAR_RESOURCES);
        var envVarEditor = $.getenv(C_ENVVAR_EDITOR);
        log ("Loaded envVarUtils = " + envVarUtils, 1, 2);
        log ("Loaded envVarEngine = " + envVarEngine, 1, 2);
        log ("Loaded envVarResources = " + envVarResources, 1, 2);
        log ("Loaded envVarEditor = " + envVarEditor, 1, 2);
        if ((envVarUtils == null) || (envVarEngine == null) || (envVarResources == null) || (envVarEditor == null)) result = false
        if (result) {
            app.ls3DCustomData.utilsPath = envVarUtils;
            app.ls3DCustomData.enginePath = envVarEngine;
            app.ls3DCustomData.resourcesPath = envVarResources;
            app.ls3DCustomData.editorPath = envVarEditor;
        } else {
            app.ls3DCustomData.utilsPath = "";
            app.ls3DCustomData.enginePath = "";
            app.ls3DCustomData.resourcesPath = "";
            app.ls3DCustomData.editorPath = "";
        }
        log("END: LoadSystemPathsFromEnvVariables() = " + result.toString(), 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SaveSystemPathsToEnvVariables()
    {
        log("START: SaveSystemPathsToEnvVariables()", 1, 3);
        var envVarUtils = app.ls3DCustomData.utilsPath;
        var envVarEngine = app.ls3DCustomData.enginePath;
        var envVarResources = app.ls3DCustomData.resourcesPath;
        var envVarEditor = app.ls3DCustomData.editorPath;
        log ("Saving envVarUtils = " + envVarUtils, 1, 2);
        log ("Saving envVarEngine = " + envVarEngine, 1, 2);
        log ("Saving envVarResources = " + envVarResources, 1, 2);
        log ("Saving envVarEditor = " + envVarEditor, 1, 2);
        $.setenv(C_ENVVAR_UTILS, envVarUtils)
        $.setenv(C_ENVVAR_ENGINE, envVarEngine)
        $.setenv(C_ENVVAR_RESOURCES, envVarResources)
        $.setenv(C_ENVVAR_EDITOR, envVarEditor)
        log("END: SaveSystemPathsToEnvVariables()", 1, 3);
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadUserMapTypes(xmlFile)
    {
        try {
            var mapTypes = xmlFile.child('userMapTypes');
            var mapCount = mapTypes.elements().length();
            for (var i = 0; i < mapCount; i++) {
                var newList = new UserMapList();
                newList.name = (mapTypes.userMapList[i].@name).toString();
                newList.nodds = ((mapTypes.userMapList[i].@nodds).toString() == "true");
                var userMapList = mapTypes.userMapList[i];
                for (var j = 0; j < userMapList.elements().length(); j++) {
                    newList.mapNames.push((userMapList.string[j]).toString());
                }
                app.ls3dUserMapTypes.userMapList.push(newList);
            }
        } catch (e) { log("Unable to read 'userMapTypes'. Update Tools configuration.", 2, 2); }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadUserGroupTypes(xmlFile)
    {
        try {
            var groupTypes = xmlFile.child('userGroupTypes');
            var groupCount = groupTypes.elements().length();
            for (var i = 0; i < groupCount; i++) {
                var newList = new UserGroupList();
                newList.name = (groupTypes.userGroupList[i].@name).toString();
                var userGroupList = groupTypes.userGroupList[i];
                for (var j = 0; j < userGroupList.elements().length(); j++) {
                    newList.groupNames.push((userGroupList.string[j]).toString());
                }
                app.ls3dUserGroupTypes.userGroupList.push(newList);
            }
        } catch (e) { log("Unable to read 'userGroupTypes'. Update Tools configuration.", 2, 2); }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadGroupTypes(xmlFile)
    {
        var groupTypes = xmlFile.child('photoshopGroupTypes');
        var groupCount = groupTypes.elements().length();
        for (i = 0; i < groupCount; i++) {

            var newType = new GroupType((groupTypes.group[i].@name).toString());
            var groupNames = groupTypes.group[i].groupNames;
            
            for (j = 0; j < groupNames.elements().length(); j++) {
                newType.strings.push((groupNames.string[j]).toString());
            }
        
            var groupDescription = groupTypes.group[i].description.toString();
            newType.description = groupDescription.replace("%s", newType.strings[0])

            app.ls3dDdsExportData.groupTypes.push(newType);
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadMapChannel(channel)
    {
        var newGroup = null;
        var newChannel = null;
        var newColor = null;
        if (channel.child('group').length() == 1)           {   newGroup = (channel.child('group')).toString();             }
        if (channel.child('groupChannel').length() == 1)    {   newChannel = (channel.child('groupChannel')).toString();    }
        if (channel.child('color').length() == 1)           {   newColor = (channel.child('color')).toString();             }    
        var result = new ChannelType(newGroup, newChannel, newColor);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadMapFormat(format)
    {
        var inFormat = format.toString();
        for (var i = 0; i < C_DXT_FORMATS.length; i++) {
            if (C_DXT_FORMATS[i].toLowerCase().search(inFormat) != -1) return i;
        }
        return -1;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadMapDefaults(defaults)
    {
        var result = new Format();
        result.ddsFormat = Number(defaults.format);
        result.scale = Number(defaults.scale);
        result.scaleFilter = Number(defaults.scaleFilter);
        result.resolutionX = Number(defaults.resolutionX);
        result.resolutionY = Number(defaults.resolutionY);
        result.cubemap = (defaults.cubemap == "true");
        log("result.cubemap = " + result.cubemap, 1, 3);
        result.mipmaps = Number(defaults.mipmaps);
        result.quality = Number(defaults.quality);
        result.sharpening = Number(defaults.sharpening);
        result.filter = Number(defaults.filter);
        result.customMip = (defaults.customMip == "true");
        
        // Check for variance and related properties
        var variance = defaults.variance.@status;
        if (variance != undefined)
        {
            result.variance = Boolean(variance.@status);
            
            // Look for and get the values for requires. There could be many
            // (but for variance we only support a single)
            if (defaults.variance.requires != undefined)
            {
                var count = defaults.variance.requires.length();
                for (var i=0; i < defaults.variance.requires.length(); i++)
                {
                    result.requires.push(defaults.variance.requires[i].toString());
                }
            }
        
            // Is there a force_compressor here? If so, use that.
            if (defaults.variance.force_compressor != undefined)
                result.force_compressor = Number(defaults.variance.force_compressor);
        }
        
        return result;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadMapTypes(xmlFile)
    {
        var mapTypes = xmlFile.child('photoshopMapTypes');
        var mapCount = mapTypes.elements().length();
        for (var i = 0; i < mapCount; i++) {
            var newType = new MapType((mapTypes.map[i].@name).toString());
            var channels = mapTypes.map[i].channels;
            for (var j = 0; j < channels.elements().length(); j++) {
//                log(channels.channel[j].@name, 1, 4);
                switch ((channels.channel[j].@name).toString()) {
                    case "r":
                            newType.red = ReadMapChannel(channels.channel[j]);
                        break;
                    case "g":
                            newType.green = ReadMapChannel(channels.channel[j]);
                            break;
                    case "b":
                            newType.blue = ReadMapChannel(channels.channel[j]);                
                        break;
                    case "a":
                            newType.alpha = ReadMapChannel(channels.channel[j]);                
                        break;
                    default:
                        log("Error: problem in configuration. Unknown channel type.", 3, 1);
                        break;                
                }
        // newType.strings.push(groupNames.string[j]);
            }
            var formats = mapTypes.map[i].formats;
            for (var j = 0; j < formats.elements().length(); j++) {
               newType.formats.push(ReadMapFormat(formats.format[j]));
            }        
            newType.defaults = ReadMapDefaults(mapTypes.map[i].defaults);
            newType.suffix = (mapTypes.map[i].suffix).toString();
            app.ls3dDdsExportData.mapTypes.push(newType);    
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetCompressorPaths(compressorIndex)
    {
        var compParams;
        if (app.ls3dCompressorParams == null) {
            compParams = new LS3DCompressorParams();
        } else {
            compParams = app.ls3dCompressorParams;
        }
        switch (compressorIndex)
        {
            case 0:
                compParams.compressorPath = app.C_NVIDIA_TOOLS_PATH;
                compParams.assemblePath = app.C_NVIDIA_STITCH_PATH;
            break;
            case 1:
                compParams.compressorPath = app.C_NVIDIA_TOOLS_2_PATH;
                compParams.scalePath = app.C_NVIDIA_TOOLS_2_SCALE_PATH;
                compParams.assemblePath = app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH;
            break;
            case 2:
                compParams.compressorPath = app.C_TEXCONV_PATH;
                compParams.assemblePath = app.C_TEXASSEMBLE_PATH;
            break;
            case 3:
                compParams.compressorPath = app.C_2KCOMPRESS_PATH;
                // FOLLOWUP : not totally sure what this does...
                compParams.assemblePath = app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH;
            break;
            default:
                log("Used unknown compression tool. Can't continue. Used compressorIndex = " + compressorIndex.toString(), 3, 1);
                return null;
            break;
        }
        compParams.compressorName = C_COMPRESSORS[compressorIndex];
        return compParams;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadGlobalConfig(xmlFile)
    {
        var globalConfig = xmlFile.child('globalConfig');
        app.C_NVIDIA_TOOLS_PATH = globalConfig.child('C_NVIDIA_TOOLS_PATH').@data.toString();
        app.C_NVIDIA_TOOLS_2_PATH = globalConfig.child('C_NVIDIA_TOOLS_2_PATH').@data.toString();
        app.C_NVIDIA_TOOLS_2_SCALE_PATH = globalConfig.child('C_NVIDIA_TOOLS_2_SCALE_PATH').@data.toString();
        app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH = globalConfig.child('C_NVIDIA_TOOLS_2_ASSEMBLE_PATH').@data.toString();
        app.C_NVIDIA_STITCH_PATH = globalConfig.child('C_NVIDIA_STITCH_PATH').@data.toString();
        app.C_TEXCONV_PATH = globalConfig.child('C_TEXCONV_PATH').@data.toString();
        app.C_2KCOMPRESS_PATH = globalConfig.child('C_2KCOMPRESS_PATH').@data.toString();
        app.C_TEXASSEMBLE_PATH = globalConfig.child('C_TEXASSEMBLE_PATH').@data.toString();
        app.C_PERFORCE_ENABLED = globalConfig.child('C_PERFORCE_ENABLED').@data.toString();
        app.C_FILE_EXTENSION_SOURCE = globalConfig.child('C_FILE_EXTENSION_SOURCE').@data.toString();
        app.C_FILE_EXTENSION_EXPORT = globalConfig.child('C_FILE_EXTENSION_EXPORT').@data.toString();
        app.C_SUFFIX_SEPARATOR = globalConfig.child('C_SUFFIX_SEPARATOR').@data.toString();
        app.C_CHANNEL_NAME_RED = globalConfig.child('C_CHANNEL_NAME_RED').@data.toString();
        app.C_CHANNEL_NAME_GREEN = globalConfig.child('C_CHANNEL_NAME_GREEN').@data.toString();
        app.C_CHANNEL_NAME_BLUE = globalConfig.child('C_CHANNEL_NAME_BLUE').@data.toString();
        app.C_CHANNEL_NAME_ALPHA = globalConfig.child('C_CHANNEL_NAME_ALPHA').@data.toString();
        app.C_BASE_EXPORT_PATH = globalConfig.child('C_BASE_EXPORT_PATH').@data.toString();      

        var branchPath = app.ls3DCustomData.editorPath.replace("\\fusion\\", "");
        branchPath = branchPath.replace("xcache", "");      // hack to get correct path when DLC is enabled
        app.C_TEXCONV_PATH = app.C_TEXCONV_PATH.replace("%BRANCH_PATH%", branchPath);
        app.C_TEXASSEMBLE_PATH = app.C_TEXASSEMBLE_PATH.replace("%BRANCH_PATH%", branchPath);
        app.C_2KCOMPRESS_PATH = app.C_2KCOMPRESS_PATH.replace("%BRANCH_PATH%", branchPath);

        if (app.ls3DCustomData.editorPath == "")
        {
            app.C_TEXCONV_PATH = app.C_TEXCONV_PATH_HACKED;
            app.C_TEXASSEMBLE_PATH = app.C_TEXASSEMBLE_PATH_HACKED;
            app.C_2KCOMPRESS_PATH = app.C_2KCOMPRESS_PATH_HACKED;
        }

        log("Global config --------------------------------------------", 1, 3);
        log("  C_NVIDIA_TOOLS_PATH: " + app.C_NVIDIA_TOOLS_PATH, 1, 3);
        log("  C_NVIDIA_TOOLS_2_PATH: " + app.C_NVIDIA_TOOLS_2_PATH, 1, 3);
        log("  C_NVIDIA_TOOLS_2_SCALE_PATH: " + app.C_NVIDIA_TOOLS_2_SCALE_PATH, 1, 3);
        log("  C_NVIDIA_TOOLS_2_ASSEMBLE_PATH: " + app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH, 1, 3);
        log("  C_NVIDIA_STITCH_PATH: " + app.C_NVIDIA_STITCH_PATH, 1, 3);
        log("  C_TEXCONV_PATH: " + app.C_TEXCONV_PATH, 1, 3);
        log("  C_TEXASSEMBLE_PATH: " + app.C_TEXASSEMBLE_PATH, 1, 3);
        log("  C_PERFORCE_ENABLED: " + app.C_PERFORCE_ENABLED, 1, 3);
        log("  C_FILE_EXTENSION_SOURCE: " + app.C_FILE_EXTENSION_SOURCE, 1, 3);
        log("  C_FILE_EXTENSION_EXPORT: " + app.C_FILE_EXTENSION_EXPORT, 1, 3);
        log("  C_SUFFIX_SEPARATOR: " + app.C_SUFFIX_SEPARATOR, 1, 3);
        log("  C_CHANNEL_NAME_RED: " + app.C_CHANNEL_NAME_RED, 1, 3);
        log("  C_CHANNEL_NAME_GREEN: " + app.C_CHANNEL_NAME_GREEN, 1, 3);
        log("  C_CHANNEL_NAME_BLUE: " + app.C_CHANNEL_NAME_BLUE, 1, 3);
        log("  C_CHANNEL_NAME_ALPHA: " + app.C_CHANNEL_NAME_ALPHA, 1, 3);
        log("  C_BASE_EXPORT_PATH: " + app.C_BASE_EXPORT_PATH, 1, 3);
        log("----------------------------------------------------------", 1, 3);
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function LoadConfigXML(path)
    {
        log("Loading config: " + path, 1, 3);
        var xmlFile = null;
        try {
            var file = new File(path);
            file.open('r');
            xmlFile = new XML(file.read());
            file.close();
        } catch (e) { log("Loading config XML error: " + e, 3, 1); return false; }
//        $.setenv("CONFIG_XML_DATA", xmlFile);

//        xmlFile = null;
//        xmlFile = new XML($.getenv("CONFIG_XML_DATA"));
        if (xmlFile == null) { log("Unknown error while loading config XML.", 3, 1); return false; } 
        log(xmlFile, 1, 0);
        
        ReadGlobalConfig(xmlFile);
        
        if (app.C_NVIDIA_TOOLS_PATH == "") {
            log("Ouch. No paths to exporters found. Can't continue. Try to start export again.\n", 3, 1);
            var errorMessage = "ConfigXml = \n" + xmlFile;
            log(xmlFile, 3, 0);
            return false;
        }
        ReadGroupTypes(xmlFile);
        ReadMapTypes(xmlFile);
        ReadUserMapTypes(xmlFile);
        ReadUserGroupTypes(xmlFile);
        log("Load done", 1, 3);
        return true;
    }

    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ReadEnginePath(regQuery, first)
    {
        var result = "";
         if (app.EXTERNAL_OBJECT == null) {
            var regResultPath =  "d:\\" + "reg_result.txt"
            RunExternalProcess("reg.exe", regQuery + " > " + regResultPath);
            
            if (first) $.sleep (C_READ_ENGINE_PATH_SLEEP);                              // wait a while so result file can be created
            else $.sleep (C_READ_ENGINE_PATH_SLEEP_BACKUP);
            
            var file = new File(regResultPath);
            file.open('r');
            var regResult = file.readln();
            regResult = file.readln();
            var parts = file.readln().split("    ");        // I'm interested in 3rd line...
            result = parts[parts.length - 1];       //... and last part of that line
            result = result.toLowerCase();
            log("ReadEnginePath: " + result, 1, 3);
            file.close();
            RunExternalProcess("del", "\"" + regResultPath + "\"");
            
            if (first) $.sleep (C_READ_ENGINE_PATH_SLEEP);                              // wait a while so result file can be created
            else $.sleep (C_READ_ENGINE_PATH_SLEEP_BACKUP);
            
            if (first) {
                if (result == "") { result = ReadEnginePath(regQuery, false); }
            }
        } else {
            result = ExtReadEnginepath(regQuery);
        }
        if (result[result.length - 1] != "\\") result += "\\";      // always add \ at the end
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ExportersInstalationTest()
    {
        var result = true;
        if (!(File(app.C_NVIDIA_TOOLS_PATH).exists)) {
            log("You don't have NVIDIA Tools installed. Can't continue.\n" + app.C_NVIDIA_TOOLS_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        if (!(File(app.C_NVIDIA_TOOLS_2_PATH).exists)) {
            log("You don't have NVIDIA Tools installed. Can't continue.\n" + app.C_NVIDIA_TOOLS_2_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        if (!(File(app.C_NVIDIA_TOOLS_2_SCALE_PATH).exists)) {
            log("You don't have NVIDIA Tools installed. Can't continue.\n" + app.C_NVIDIA_TOOLS_2_SCALE_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        if (!(File(app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH).exists)) {
            log("You don't have NVIDIA Tools installed. Can't continue.\n" + app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        if (!(File(app.C_NVIDIA_STITCH_PATH).exists)) {
            log("You don't have NVIDIA Tools installed. Can't continue.\n" + app.C_NVIDIA_STITCH_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        if (!(File(app.C_TEXCONV_PATH).exists)) {
            log("You don't have DDS compressing tools installed. Can't continue.\n" + app.C_TEXCONV_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        if (!(File(app.C_TEXASSEMBLE_PATH).exists)) {
            log("You don't have DDS compressing tools installed. Can't continue.\n" + app.C_TEXASSEMBLE_PATH + " is missing.\nIf you don't know what to do, ask your leader for help.", 3, 1);
            result = false;
        }
        return result;
    }
}
//--------- /END LOAD CONFIG --------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- EXTERNAL PROCESS --------------------------------------------------------------------------------------------------------------------------------------------------------
{
    
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ParseExtResult_DDS1(input, returnObject)
    {
        var result = "";
        var exportOkResult = input.search("time taken");
        if (exportOkResult != -1) {
            var splitInput = input.split(" ");
            splitInputCount = splitInput.length - 2;
            result = C_DDS_EXPORT_RESULTS[0];
            returnObject.timeValue = Number(splitInput[splitInputCount]);
            return result;
        }
        exportOkResult = input.search("is not a supported image type.");
        if (exportOkResult != -1) {
            result = C_DDS_EXPORT_RESULTS[2];
            return result;
        }
        exportOkResult = input.search("Error opening");
        if (exportOkResult != -1) {
            result = C_DDS_EXPORT_RESULTS[3];
            return result;
        }
        return C_DDS_EXPORT_RESULTS[1];
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ParseExtResult(input, inputType, returnObject)
    {
        log("START: ParseExtResult( ... , " + inputType + ")", 1, 3);
        var result = ""
        var exportTime = 0;
        switch (inputType) {
            case C_INPUT_TYPES[0]:
                result = ParseExtResult_DDS1(input, returnObject);
                break;
            case C_INPUT_TYPES[1]:
                break;
            default:
                log("Error: problem in parsing external result. Unknown input type.", 3, 1);
                break;
        }
        log("END: ParseExtResult()", 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FileInP4Test(filename)
    {
        if (app.C_PERFORCE_ENABLED == "false") return 0;
        var result = 1;
        if (app.EXTERNAL_OBJECT == null) {
            var str = "fstat " + filename;
            var randomNumber = Math.round(Math.random() * 1000);
            var p4ResultPath =  "d:\\" + "p4_result_" + randomNumber + ".txt"
            RunExternalProcess("p4", str + " >" + p4ResultPath + " 2>&1");
            $.sleep (100);                              // wait a while so result file can be created
            try {
                var file = new File(p4ResultPath);
                file.open('r');
                var p4Result = file.readln();
                file.close();
            } catch (e) { log("FileInP4Test() error: " + e, 3, 1); return false; }
            if (C_DELETE_TEMP_COMMAND) RunExternalProcess("del", "\"" + p4ResultPath + "\"");
            $.sleep (100);
            log("ReadP4Result: " + p4Result, 1, 3);
            
            if (p4Result == "") result = -1;
            else if(p4Result.search("no such file")!=-1) result = 2;
                else if(p4Result.search("is not under client")!=-1) result = 100;
                    else if(p4Result.search("not in client view.")!=-1) result = 101;
                        else if(p4Result.search("Perforce password")!=-1) result = 102;
                            else if(p4Result.search("is not recognized")!=-1) result = 103;
        } else {
            app.ls3dP4ResultTypes = new P4ResultTypes();
            var returnObject = { timeValue:0 }
            result = P4Fstat(filename, returnObject);

            log("result: " + result, 2, 1);

        }
        log("FileInP4Test: " + result, 1, 3);
        return result;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function P4Results(p4Test, targetDDS, firstPart)
    {
        var str = "";
        if (firstPart) {
            switch (p4Test) {
                case -1: log("No result from fstat command. Automatic checkout is not available.", 2, 2); break;   // P4 disabled
                case 0: log("Perforce support disabled by settings. Automatic checkout is not available.", 2, 2); break;   // P4 disabled
                case 1: str = "p4 edit -f " + targetDDS; log("P4 command: " + str, 1, 2); break;     // P4 checkout
                case 2: break;
                case 3: log("Exported file is marked to be deleted in perforce. Stopping export.", 3, 1); str = "STOP"; break;
                case 4: log("File opened for edit.", 1, 2); break;
                case 100: log("You are trying to export outside of workspace directory. Automatic checkout is not available.", 3, 1);  break;
                case 101: log("You are trying to export to nonexisting directory. Automatic checkout is not available.", 3, 1);        break;
                case 102: log("You are not logged into Perforce. Automatic checkout is not available.", 3, 1);                         break;
                case 103: log("You don't have Perforce client installed. Automatic checkout is not available.", 3, 1);                 break;
                case 200: break;        // no action
                default: log("Unknown error. Automatic checkout is not available.", 3, 1);
            }
        } else {
            if (p4Test == 2) {            //P4 Add when new file is created
                str = "p4 add " + targetDDS; 
                log("P4 command: " + str, 1, 2); 
                str += "\nping 123.45.67.89 -n 1 -w 500 > nul"
            }
        }
        return str;
    }
    

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function TestExportFormatID(input)
    {
        if ((input < 0) || (input >= C_DXT_FORMATS.length)) {
            log("Unknown export format ID: " + input + " Can't continue.\nConfiguration probably changed, try open configuration UI and save it again please.", 3, 1);
            return false;
        }
        return true
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_DDSUtils_ConvertExportFormat(input, isNormalMap, hasAlpha)     // use this function for app.C_NVIDIA_TOOLS_PATH compressor
    {
        log("START: Compress_DDSUtils_ConvertExportFormat(" + input + ", " + isNormalMap + ")", 1, 3);        
        var result = "";
        var formatInput = C_DXT_FORMATS[input];
        switch (formatInput)
        {
            case C_DXT_FORMATS[0]:
            case C_DXT_FORMATS[1]:{
                    if (isNormalMap) { result = "dxt1nm";
                    } else {
                        if (hasAlpha) { result = "dxt1a";
                        } else { result = "dxt1"; }
                    } 
                }
                break;
            case C_DXT_FORMATS[2]: {
                    result = "dxt3";
                } 
                break;
            case C_DXT_FORMATS[3]: {
                    if (isNormalMap) { result = "dxt5nm"
                    } else { result = "dxt5"; }
                }
                break;
            default: {
                    log("Unknown export format ID: " + input + " Can't continue.", 3, 1);
                } 
                break;
        }
        log("END: Compress_DDSUtils_ConvertExportFormat() = " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_TexTools2_ConvertExportFormat(input, isNormalMap, hasAlpha)     // use this function for app.C_NVIDIA_TOOLS_2_PATH compressor
    {
        log("START: Compress_TexTools2_ConvertExportFormat(" + input + ", " + isNormalMap + ")", 1, 3);        
        var result = "";        
        var formatInput = C_DXT_FORMATS[input];
        switch (formatInput)
        {
            case C_DXT_FORMATS[0]:
            case C_DXT_FORMATS[1]:{
                    if (isNormalMap) result = "bc1n";
                    else {
                        if (hasAlpha) result = "bc1a";
                        else result = "bc1";
                    }            
                } 
                break;
            case C_DXT_FORMATS[2]: {
                    result = "bc2";
                } 
                break;
            case C_DXT_FORMATS[3]: {
                    if (isNormalMap) result = "bc3n"
                    else result = "bc3";
                } 
                break;
            default: {
                    log("Unknown export format ID: " + input + " Can't continue.", 3, 1);
                }
                break;
        }        
        log("END: Compress_TexTools2_ConvertExportFormat() = " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_TexConv_ConvertExportFormat(input, isNormalMap, hasAlpha)     // use this function for app.C_TEXCONV_PATH compressor
    {
        log("START: Compress_TexConv_ConvertExportFormat(" + input + ", " + isNormalMap + ")", 1, 3);        
        var result = "f ";
        var formatInput = C_DXT_FORMATS[input];
        switch (formatInput)
        {
            case C_DXT_FORMATS[0]:
            case C_DXT_FORMATS[1]: {
                    result += "BC1_UNORM";
                } 
                break;
            case C_DXT_FORMATS[2]: {
                    result += "BC1_UNORM";
                } 
                break;
            case C_DXT_FORMATS[3]: {
                    result += "BC3_UNORM";
                } 
                break;
            case C_DXT_FORMATS[4]: {
                    result += "BC4_UNORM";
                } 
                break;
            case C_DXT_FORMATS[5]: {
                    result += "BC5_UNORM";
                } 
                break;
            case C_DXT_FORMATS[6]: {
                    result += "BC6H_UF16";
                } 
                break;
            case C_DXT_FORMATS[7]: {
                    result += "BC7_UNORM";
                } 
                break;
            case C_DXT_FORMATS[8]: {
                    result += "R8G8B8A8_UNORM_SRGB";
                } 
                break;				
            default: {
                    log("Unknown export format ID: " + input + " Can't continue.", 3, 1);
                }
                break;
        } 
        log("END: Compress_TexConv_ConvertExportFormat() = " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_DDSUtils(compressionParams, enableP4, wait)
    {
        var targetDDS = compressionParams.outPath + compressionParams.outFile + compressionParams.outType;
        var tempPSD = compressionParams.inPath + compressionParams.inFile + compressionParams.inType;
        var exportFormat = " -" + Compress_DDSUtils_ConvertExportFormat(compressionParams.format, compressionParams.isNormalMap, compressionParams.hasAlpha);
        var nMipMaps = " -nmips " + compressionParams.mipCount.toString();
        var arguments = " -file \"" + tempPSD + "\" -output \"" + targetDDS + "\"" + exportFormat + " " + nMipMaps;
        RunExternalDDSCompressor("\"" + compressionParams.compressorPath + "\"", arguments, targetDDS, tempPSD, enableP4, wait);
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_TexTools2(compressionParams, enableP4, wait)
    {
        var targetDDS = compressionParams.outPath + compressionParams.outFile + compressionParams.outType;
        var tempPSD = compressionParams.inPath + compressionParams.inFile + compressionParams.inType;
        var exportFormat = " -" + Compress_TexTools2_ConvertExportFormat(compressionParams.format, compressionParams.isNormalMap, compressionParams.hasAlpha);
        var nMipMaps = "";
        if (compressionParams.mipCount == 1) {
            nMipMaps = " -nomips"
        }
        var arguments = exportFormat + " " + nMipMaps + " \"" + tempPSD + "\" \"" + targetDDS + "\"";
        RunExternalDDSCompressor("\"" + compressionParams.compressorPath + "\"", arguments, targetDDS, tempPSD, enableP4, wait);
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_TexConv(compressionParams, enableP4, wait, keepSource)
    {
        var targetDDSPath = compressionParams.outPath;
        var targetDDS = targetDDSPath + compressionParams.outFile + compressionParams.outType;
        var tempPSD = compressionParams.inPath + compressionParams.inFile + compressionParams.inType;
        var lengthMinOne = targetDDSPath.length - 1;
        if ((targetDDSPath[lengthMinOne] == "\\") || (targetDDSPath[lengthMinOne] == "/")) {
            targetDDSPath = targetDDSPath.substr(0, lengthMinOne);
        }
        var exportFormat = " -" + Compress_TexConv_ConvertExportFormat(compressionParams.format, compressionParams.isNormalMap);
        var nMipMaps = " -m " + compressionParams.mipCount.toString();
        var width = " -w " + compressionParams.width.toString();
        var height = " -h " + compressionParams.height.toString();
        var arguments = exportFormat + " -ft dds" + " -sepalpha -wrap -nologo" + nMipMaps + width + height + " -o \"" + targetDDSPath + "\" \"" + tempPSD + "\"";
        var bkp = app.C_DELETE_TEMP_FILES;
        if(keepSource) {
            app.C_DELETE_TEMP_FILES = false;
            tempPSD = "";
        }
        RunExternalDDSCompressor("\"" + compressionParams.compressorPath + "\"", arguments, targetDDS, tempPSD, enableP4, wait);
        app.C_DELETE_TEMP_FILES = bkp;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Compress_2KCompress_Variance(compressionParams, enableP4, wait, keepSource)
    {
        var targetDDSPath = compressionParams.outPath;
        var targetDDS = targetDDSPath + compressionParams.outFile + compressionParams.outType;
        var tempPSD = compressionParams.inPath + compressionParams.inFile + compressionParams.inType;
        
        // Get the exportFormat for the output
        var exportFormat = C_DXT_FORMATS[compressionParams.format];
        switch(exportFormat)
        {
            case C_DXT_FORMATS[0]:
                exportFormat = "bc1";
                break;
            case C_DXT_FORMATS[1]:
                exportFormat = "bc1a";
                break;
            case C_DXT_FORMATS[2]:
                exportFormat = "bc2";
                break;
            case C_DXT_FORMATS[3]:
                exportFormat = "bc3";
                break;
            case C_DXT_FORMATS[4]:
                exportFormat = "bc4";
                break;
            case C_DXT_FORMATS[5]:
                exportFormat = "bc5";
                break;
            default:
            {
                // Default to dxt1 if it doesn't have alpha,
                // and dxt5 if it does.
                if (compressionParams.hasAlpha)
                    exportFormat = "bc3";
                else
                    exportFormat = "bc1";
                break;
            }
        };
        
        // Construct args and call the compressor
        var compargs = "";
        if (compressionParams.requires.length)
        {
            // Variance requires a normal map, which in this case would just be the first one on the stack
            compargs += " -v -r -n \"" + compressionParams.requires[0] + "\"";
        }
        compargs += " -f " + exportFormat + " -i \"" + tempPSD + "\" -o \"" + targetDDS + "\"";
        RunExternalDDSCompressor("\"" + compressionParams.compressorPath + "\"", compargs, targetDDS, tempPSD, enableP4, wait);
        if (app.C_DELETE_TEMP_FILES && compressionParams.requires.length)
        {
            if (app.C_DELETE_TEMP_FILES) DeleteFileFromDLL(compressionParams.requires[0]);
        }
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetCubeFileName(name, index)
    {
        var result = "cube";
        if (index == -1) { 
            result += ("_temp_" + name);
        } else {
            result += (index.toString() + "_" + name);
        }
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CleanCubeTempFiles(tempDocuments, compressionParams)
    {
        for (var i = 0; i < 6; i++) {
            var tempFilePath = compressionParams.inPath + GetCubeFileName(compressionParams.inFile, i) + compressionParams.inType;
            DeleteFile(tempFilePath);
            var doc = tempDocuments[i];
            doc.close(SaveOptions.DONOTSAVECHANGES);
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Stitch_TexConv(stitchType, compressionParams, enableP4, wait)
    {
        var targetDDSPath = compressionParams.outPath;
        var targetDDS = targetDDSPath + compressionParams.outFile + compressionParams.outType;
        var tempPSD = compressionParams.inPath + compressionParams.inFile + compressionParams.inType;
        var width = " -w " + compressionParams.width.toString();
        var height = " -h " + compressionParams.height.toString();
        var exportFormat = " -f R8G8B8A8_UNORM";// + Compress_TexConv_ConvertExportFormat(compressionParams.format, compressionParams.isNormalMap);
        var args = " -" + stitchType;
        args += " -sepalpha" + " -o " + targetDDS + width + height + exportFormat;
        switch(stitchType)
        {
            case "cube":                
                var cubeNames = Array();
                var cubeFiles = "";
                for (var i = 0; i < 6; i++) {
                    cubeFiles += " ";
                    cubeFiles += (compressionParams.inPath + GetCubeFileName(compressionParams.inFile, i)) + compressionParams.inType;
                }
                args += cubeFiles;
                log("List of files for stitch: " + cubeFiles, 1, 3);
            break;
            case "volume":
            break;
            case "array":
            break;
            case "cubearray":
            break;
            default:
                log("Unknown stitch type = " + stitchType, 3, 1);
                return false;
        }
        RunExternalDDSCompressor("\"" + compressionParams.assemblePath + "\"", args, targetDDS, tempPSD, false, wait);
        return true;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function PickExternalCompressor(compressorIndex, enableP4, wait)
    {
        log("START: PickExternalCompressor()", 1, 3);
        
        if (app.ls3dCompressorParams.nodds) {
            log("Parameter nodds == true. Saving only TGA. Not exporting DDS", 1, 3);
            
            
            log("END: PickExternalCompressor()", 1, 3);
            return true;
        }
        
        // Check to see if this is forcing a compressor
        if (app.ls3dCompressorParams.force_compressor == -1) {
            if ((compressorIndex == 1) && (app.ls3dCompressorParams.customMips)) {   // custom mipmap count
                compressorIndex = 0;
            }

            // TexConv is used only for BC4, BC5, BC6, BC7. Not for DXT1 and DXT5
            // This is because current version is producing artefacts in R and B channels.
            var format = app.ls3dCompressorParams.format;
            if ((compressorIndex == 2) && (format <= 2)) {
                compressorIndex = 1;
            }
            if (app.ls3dCompressorParams.cubemap) {
                compressorIndex = 2;
            }        
        }
        else
            compressorIndex = app.ls3dCompressorParams.force_compressor;
        
        app.ls3dCompressorParams = GetCompressorPaths(compressorIndex);
        
        if (TestExportFormatID(app.ls3dCompressorParams.format)) {
            log("Selected compressor index = " + compressorIndex.toString(), 1, 3);
            switch (compressorIndex)
            {
                case 0:
                    Compress_DDSUtils(app.ls3dCompressorParams, enableP4, wait);
                    break;
                case 1:
                    Compress_TexTools2(app.ls3dCompressorParams, enableP4, wait);
                    break;
                case 2:
                    if (app.ls3dCompressorParams.cubemap) {
                        var cubeDocuments = GenerateCubeTextures(app.ls3dCompressorParams);
                        var compressorParams = app.ls3dCompressorParams.Copy();
                        if (cubeDocuments.length > 0) {
                            compressorParams.inFile = app.ls3dCompressorParams.inFile;
                            compressorParams.outFile = app.ls3dCompressorParams.outFile;
                            if (!Stitch_TexConv("cube", compressorParams, enableP4, wait)) {
                                log("END: PickExternalCompressor()", 1, 3);
                                CleanCubeTempFiles(cubeDocuments, compressorParams);
                                return false;
                            }
                            CleanCubeTempFiles(cubeDocuments, compressorParams);
                            compressorParams.inFile = compressorParams.outFile;
                            compressorParams.inType = app.C_FILE_EXTENSION_EXPORT;
                            compressorParams.outFile = app.ls3dCompressorParams.outFile;
                            Compress_TexConv(compressorParams, enableP4, wait, true);
                        } else {
                            log("END: PickExternalCompressor()", 1, 3);
                            return false;
                        }
                    } else {
                        Compress_TexConv(app.ls3dCompressorParams, enableP4, wait, false);
                    }
                    break;
                // Variance exporting using 2K Compress
                case 3:
                    Compress_2KCompress_Variance(app.ls3dCompressorParams, enableP4, wait);
                    break;
                default:
                    log("Error: Unsupported compression type. Please consult allowed formats with technical artists.", 3, 1);
                    log("END: PickExternalCompressor()", 1, 3);
                    return false;
                    break;
            }        
        } else {
            log("END: PickExternalCompressor()", 1, 3);
            return false;
        }
        log("END: PickExternalCompressor()", 1, 3);
        return true;
    }
        
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RunMipmapStitch(appName, ddsPath, mipCount, enableP4)
    {
         var str = "";
        var p4Test = 200;
        
        if (enableP4)
        {
            p4Test = FileInP4Test(ddsPath + app.C_FILE_EXTENSION_EXPORT);
            str = P4Results(p4Test, ddsPath + app.C_FILE_EXTENSION_EXPORT, true);
        }
        
        const C_MAX_SAFEBREAK = 10;
        var safeBreak = 0;
        log("Waiting for " + ddsPath + "_00" + app.C_FILE_EXTENSION_EXPORT + " creation.", 1, 3);
        while (!(File(ddsPath + "_00" + app.C_FILE_EXTENSION_EXPORT).exists) && (safeBreak < C_MAX_SAFEBREAK))
        {
            log("Exist result = " + (File(ddsPath + "_00" + app.C_FILE_EXTENSION_EXPORT).exists), 1, 3);
            $.sleep(1000);
            safeBreak += 1;
        }
        if (safeBreak == C_MAX_SAFEBREAK) {
            log("RunMipmapStitch() error: " + ddsPath + "_00" + app.C_FILE_EXTENSION_EXPORT + " does not exist. Can't stitch mipmaps.", 3, 1);
            return false;
        }
        if (app.EXTERNAL_OBJECT == null) {
            try {
                var randomNumber = Math.round(Math.random() * 1000);
                var bat = new File(Folder.temp + "/dds_stitch_" + randomNumber + ".cmd");
                bat.open("w");
                
                if (enableP4)
                {
                    bat.writeln(str);                       // add P4 checkout command
                    bat.writeln("ping 123.45.67.89 -n 1 -w 1500 > nul");
                }
            
                bat.writeln("del \"" + (ddsPath + app.C_FILE_EXTENSION_EXPORT) + "\" > NUL");     // delete existing dds file before stitch
                str = appName + " " + ddsPath;          // + " >> log.txt";
                log("Stitch command: " + str, 1, 3);
                bat.writeln(str);                       // add export command
                bat.writeln("ping 123.45.67.89 -n 1 -w 500 > nul");
                
                if (enableP4)
                {
                    str = P4Results(p4Test, ddsPath + app.C_FILE_EXTENSION_EXPORT, false);
                    bat.writeln(str);                       // add P4 add command
                }
                
                if (app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS) bat.writeln("pause");
                app.C_DELETE_TEMP_FILES = !app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS;  // will not delete temp TGA file
                for (i = 0; i < mipCount; i++) {
                    var suffix = "_";
                    if (i < 10) suffix += "0";
                    suffix += i;
                    if (app.C_DELETE_TEMP_FILES) bat.writeln("del \"" + (ddsPath + suffix + app.C_FILE_EXTENSION_EXPORT) + "\" > NUL");
                }
                if (C_DELETE_TEMP_COMMAND) bat.writeln("del \"" + bat.fsName + "\" > NUL");
                bat.close();
                bat.execute();
                $.sleep(200);
            } catch (e) { log("RunMipmapStitch() error: " + e, 3, 1); return false; }
        } else {
            DeleteFile(ddsPath + app.C_FILE_EXTENSION_EXPORT);
            StitchCommand(appName, ddsPath);
            for (i = 0; i < mipCount; i++) {
                var suffix = "_";
                if (i < 10) suffix += "0";
                suffix += i;
                if (app.C_DELETE_TEMP_FILES) {
                    DeleteFile(ddsPath + suffix + app.C_FILE_EXTENSION_EXPORT);
                }
            }            
        }
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RunExternalDDSCompressor(appName, args, targetDDS, sourceFile, enableP4, wait)
    {
        var str = "";
        var p4Test = 200;
        if (enableP4) {
            p4Test = FileInP4Test(targetDDS);
            str = P4Results(p4Test, targetDDS, true);
        }

        const C_MAX_SAFEBREAK = 10;
        var safeBreak = 0;
        if (!((app.C_DELETE_TEMP_FILES == false) && (sourceFile == ""))) {
            log("Waiting for " + sourceFile + " creation.", 1, 3);
            while (!(File(sourceFile).exists) && (safeBreak < C_MAX_SAFEBREAK))
            {
                log("Exist result = " + (File(sourceFile).exists), 1, 3);
                $.sleep(1000);
                safeBreak += 1;
            }
            if (safeBreak == C_MAX_SAFEBREAK) {
                log("RunExternalDDSCompressor() error: " + sourceFile + " does not exist. Can't export dds.", 3, 1);
                return false;
            }
        }
        
        if (app.EXTERNAL_OBJECT == null) {
            try {
                var randomNumber = Math.round(Math.random() * 1000);
                var bat = new File(Folder.temp + "/dds_compress_" + randomNumber + ".cmd");
                bat.open("w");
                if (enableP4) {
                    bat.writeln(str);                       // add P4 checkout command
                    bat.writeln("ping 123.45.67.89 -n 1 -w 500 > nul");
                }
                str = appName + " " + args;             // + " >> log.txt";
                log("Export command: " + str, 1, 2);
                bat.writeln(str);                       // add export command
                bat.writeln("ping 123.45.67.89 -n 1 -w " + (wait * 2) + " > nul");
                if (enableP4) {
                    str = P4Results(p4Test, false);
                    bat.writeln(str);                       // add P4 add command
                }
                if (app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS) bat.writeln("pause");
                if (app.C_DELETE_TEMP_FILES) bat.writeln("del \"" + sourceFile + "\" > NUL");
                if (C_DELETE_TEMP_COMMAND) bat.writeln("del \"" + bat.fsName + "\" > NUL");
                
                bat.close();
                bat.execute();
                $.sleep(200);
            } catch (e) { log("RunExternalDDSCompressor() error: " + e, 3, 1); return false; }
        } else {
            log("Export. Appname: " + appName, 1, 2);
            log("Arguments: " + args, 1, 2);
            RunExternalProcessFromDLL(appName, args);
            
            if (app.C_DELETE_TEMP_FILES) DeleteFileFromDLL(sourceFile);
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RunExternalProcess(appName, args)
    {
        try {
            var randomNumber = Math.round(Math.random() * 1000);
            var bat = new File(Folder.temp + "/external_process_" + randomNumber + ".cmd");
            bat.open("w");
            var str = appName + " " + args;     // + " >> log.txt";
            log("External process command: "+ str, 1, 3);
            bat.writeln(str);
            if (app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS) bat.writeln("pause");
            if (C_DELETE_TEMP_COMMAND) bat.writeln("del \"" + bat.fsName + "\" > NUL");
            bat.close();
            bat.execute();
        } catch (e) { log("RunExternalProcess() error: " + e, 3, 1); return false; }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RunExternalProcessFromDLL(appName, args)
    {
        log("RunExternalProcessFromDLL(" + appName + ", " + args + ")", 1, 3);
        if (app.EXTERNAL_OBJECT != null) {
            var returnObject = { timeValue:0 }
            try {
                var result = app.EXTERNAL_OBJECT.RunExternalFile(appName, args, "", "");
                log("External file result:", 1, 3);
                log(result, 1, 3);
                result = ParseExtResult(result, C_INPUT_TYPES[0], returnObject);
            } catch (e) {
                result = "ERROR. Unable to execute RunExternalFile(" + appName + ", " + args + ")";
                log(result, 3, 1);       
            }        
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function DeleteFileFromDLL(filename)
    {
        log("DeleteFileFromDLL(" + filename + ")", 1, 3);
        if (app.EXTERNAL_OBJECT != null) {
            var result = false;
            if (app.EXTERNAL_OBJECT != null) {
                var returnObject = { timeValue:0 }
                try {
                    var result = app.EXTERNAL_OBJECT.FileDelete(filename);
                    log("Delete file. Result: " + result, 1, 3);
                    result = true;
                } catch (e) {
                    result = false;
                }        
            }
            return result;
        }
    }
}
//--------- /END EXTERNAL PROCESS --------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- LAYER FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function BackupLayerVisibility(document)
    {
        log("START: BackupLayerVisibility()", 1, 3);
        app.layerGroupsVisibilityBackup = new Array();
        for (i = 0; i < document.layers.length; i++) {
            app.layerGroupsVisibilityBackup.push(document.layers[i].visible);
            document.layers[i].visible = false;
        }
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RestoreLayerVisibility(document)
    {
        log("START: RestoreLayerVisibility()", 1, 3);
        activeDocument = document;
        for (i = 0; i < app.layerGroupsVisibilityBackup.length; i++) {
            if (activeDocument.layers[i] != undefined) activeDocument.layers[i].visible = app.layerGroupsVisibilityBackup[i];
        }
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SetLayerGroupVisible(layerGroup, document)
    {
        if (layerGroup == null) return;
        if (layerGroup.typename == "LayerSet") {
            app.activeDocument = document;
            for (i = 0; i < activeDocument.layerSets.length; i++) {
                activeDocument.layerSets[i].visible = false;
            }
            layerGroup.visible = true;            
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SetLayerVisible(layer, document)
    {
        if (layer == null) return;
        if (layer.typename == "ArtLayer") {
            app.activeDocument = document;
            for (i = 0; i < activeDocument.artLayers.length; i++) {
                activeDocument.artLayers[i].visible = false;
            }
            layer.visible = true;            
            app.activeDocument.activeLayer = layer;
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetColapsedLayerByChannelType(sourceChannelType, document)
    {
        var layer = null;
        var sourceChannel = null;
        if (sourceChannelType == null) return false;
        if (sourceChannelType.group != null) {    // copy whole group to channel
            var groupTypeID = FindGroupTypeIDByType(sourceChannelType.group);
            if (groupTypeID == -1) return false;
            log("group Type ID = " + groupTypeID, 2, 4);
            log("app.ls3dDdsExportData.groupTypes[groupTypeID] = " + app.ls3dDdsExportData.groupTypes[groupTypeID], 2, 4);
            layer = FindCollapsedLayerByType(app.ls3dDdsExportData.groupTypes[groupTypeID], document);
            if (sourceChannelType.channel != null) {   // copy only one channel to channel
                sourceChannel = sourceChannelType.channel;
            }
        } else {
            if (sourceChannelType.color == null ){
                log("GetColapsedLayerByChannelType() - Error in configuration. No source group or color found", 3, 1);
                return false;
            }
        }
        return layer;        
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SelectChannel(color)
    {
        var desc = new ActionDescriptor();
        var ref = new ActionReference();
        log("Active document: " + activeDocument + "    Select channel: " + color, 1, 3);
        ref.putEnumerated( charIDToTypeID('Chnl'), charIDToTypeID('Chnl'), stringIDToTypeID(color) );
        desc.putReference( charIDToTypeID('null'), ref );
        executeAction( charIDToTypeID('slct'), desc, DialogModes.NO );
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function MergeGroups(document, groupsToMerge)
    {
        log("START: Merging groups", 1, 3);
        try {
            while (document.artLayers.length > 0){
                document.artLayers[0].allLocked = false
                document.artLayers[0].remove();
                UpdateWipDialog(1, "Removing art layers", false);
            }
        } catch (e) {
            log("Unable to remove root Layer. That's usualy not possible when root layer is also the last one in file. PSD is empty and there is nothing to export.", 3, 1);
            log("END: Merging groups", 1, 3);
            return false;
        }
        var tempLayers = new Array();
        for (var i = 0; i < app.CACHE_GroupLayerNames.length; i++) {
            var selectedGroupID = FindGroupTypeIDByName(app.CACHE_GroupLayerNames[i]);
            if (selectedGroupID == -1) { 
                tempLayers.push(i);
                log("REMOVE TEMP: " + app.CACHE_GroupLayerNames[i], 2, 3);
            }
        }
        for (var i = tempLayers.length - 1; i >= 0; i--) {
            UpdateWipDialog(1, "Removing unsupported/empty groups", false);
            var layerIndex = tempLayers[i];
            var layer = document.layerSets[layerIndex];
            log("   Removing layer group: " + layer.name.toString(), 1, 3);
            try {
                layer.allLocked = false
                layer.remove();
                app.CACHE_GroupLayerNames.splice(layerIndex, 1);
            } catch(e) {
                log("Failed to remove layer group: " + layer.name.toString() + ". Most probably there are some locked layers inside. Unlock them.", 3, 1);
                log("END: Merging groups", 1, 3);
                return false;
            }
        }
        if (app.CACHE_CollapsedArtLayerNames != null) {
            log("FATAL ERROR in MergeGroups() - app.CACHE_GroupLayerNames = " + app.CACHE_CollapsedArtLayerNames + "   This should not happend.", 3, 1);
            app.CACHE_CollapsedArtLayerNames = new Array();
        } else app.CACHE_CollapsedArtLayerNames = new Array();
    
        while (app.CACHE_GroupLayerNames.length > 0) {
            try {
				if  document.layerSets[0] == undefined do return false
                UpdateWipDialog(1, "Merging group: " + document.layerSets[0].name.toString(), false);
                document.activeLayer = document.layerSets[0];
                document.layerSets[0].visible = true;
                document.layerSets[0].merge();
                app.CACHE_CollapsedArtLayerNames.push(app.CACHE_GroupLayerNames[0]);
            } catch(e) {
                document.layerSets[0].allLocked = false
                document.layerSets[0].remove();
//                log("to remove: " + document.layerSets[0], 1, 4);
                log("Unable to merge Layer Group: " + app.CACHE_GroupLayerNames[0] + "  Group is probably empty. Layer Group will be deleted.   " + e, 2, 3);
            }
            app.CACHE_GroupLayerNames.splice(0, 1);
        }
        log("END: Merging groups", 1, 3);
        return true;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function DuplicateLayer(sourceDoc, targetDoc, layerGroup)
    {
        app.activeDocument = sourceDoc;
        SetLayerVisible(layerGroup, sourceDoc);                             // unhiding collapsed layer that I want to export
        CopyPasteImage(sourceDoc, null, true);
        app.activeDocument = targetDoc;
        CopyPasteImage(targetDoc, null, false);
        targetDoc.flatten();
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FixGroupNames(document)
    {
        log("START: FixGroupNames(" + document + ")", 1, 3);
        var groupTypes = app.ls3dDdsExportData.groupTypes;
        if (app.CACHE_GroupLayerNames == null) {
            app.CACHE_GroupLayerNames = CacheNames(document.layerSets);
        }
        log("END: FixGroupNames()", 1, 3);
        
        return true;
        
        /*     -- HOT FIX to be able to export roughness layer
        
        UpdateWipDialog(1, "Fixing group names.", false);
        for (var layerIndex = 0; layerIndex < app.CACHE_GroupLayerNames.length; layerIndex++) {
            var layerName = app.CACHE_GroupLayerNames[layerIndex];
            for (var i = 0; i < groupTypes.length; i++) {            
                var groupType = groupTypes[i];                
                for (var j = 1; j < groupType.strings.length; j++) {

                    if (layerName == groupType.strings[j]) {
                        
                        document.layerSets[layerIndex].name = groupType.strings[0];
                        app.CACHE_GroupLayerNames[layerIndex] = groupType.strings[j];
                    }
                }                
            }            
        }
        log("END: FixGroupNames()", 1, 3);
        */
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GenerateLayers(document, layerTypes)
    {
        document = app.activeDocument;
        log("START: GenerateLayers(" + document + ", " + layerTypes + ")", 1, 3);
        FixGroupNames(document);
//        for (var i = 0; i < app.ls3dDdsExportData.groupTypes.length; i++) log(app.ls3dDdsExportData.groupTypes[i].strings[0], 2, 4);
//        for (var i = 0; i < app.CACHE_GroupLayerNames.length; i++) log(app.CACHE_GroupLayerNames[i], 2, 4);
        var generated = false;
        for (var listIndex = 0; listIndex < app.ls3dUserGroupTypes.userGroupList.length; listIndex++) {
            if (!generated) {
                var userGroupList = app.ls3dUserGroupTypes.userGroupList[listIndex];
                if (userGroupList.name == layerTypes) {
                    app.activeDocument = document;
                    generated = true;
                    var groupNames = userGroupList.groupNames;
                    for (var i = 0; i < groupNames.length; i++) {
                        var groupAlreadyExists = false;
                        var groupName = groupNames[i];
                        for (var j = 0; j < app.CACHE_GroupLayerNames.length; j++) {
                            if (app.CACHE_GroupLayerNames[j] == groupName) groupAlreadyExists = true;
                        }
                        if (!groupAlreadyExists) {
                            log("Creating group: " + groupName, 1, 3);
                            var newGroup = app.activeDocument.layerSets.add();
                            newGroup.name = groupName;
                        }
                    }                    
                }
            }
        }
        if (!generated) { log("Unknown layer type. No layers were generated.", 3, 1);
        } else { app.CACHE_GroupLayerNames = null; }
        log("END: GenerateLayers()", 1, 3);
    }
}
//--------- /END LAYER FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- LAYER FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetPathInPSNotation(path)
    {
        var result = "";
        var splitPath = path.split("\\");
        var startIndex = 1;
        if (splitPath[0].indexOf(":") != -1) result += ("/" + splitPath[0][0]);     // drive letter
        else startIndex = 0;                // if it's relative path, take all parts and combine them again with correct slashes
        for (var i = startIndex; i < splitPath.length; i++) {
            var tempDir = splitPath[i];
            result += ("/" + tempDir);
        }           
        log("GetPathInPSNotation: " + result, 1, 3);
        result = result.toLowerCase();
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetPathInWinNotation(path)
    {
        var result = "";
        var splitPath = path.split("/");
        result = splitPath[1] + ":\\";
        for (var i = 2; i < splitPath.length; i++) { result += (splitPath[i] + "\\"); }          
        log("GetPathInWinNotation: " + result + "   path: " + path, 1, 3);
        return result;
    }    
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetAutomaticExportPath()
    {
        var result = GetPathInWinNotation(app.activeDocument.path.toString().toLowerCase());
        indexOfBranch = result.indexOf(app.ls3DCustomData.resourcesPath);
        if (indexOfBranch > -1) {
            result = result.replace (app.ls3DCustomData.resourcesPath, "");
            var charactersFound = false;
            var modelsFound = result.indexOf("models\\");
            if (modelsFound == 0) {
                result = result.replace ("models\\", "");
            } else {
                modelsFound = result.indexOf("static_objects\\");
                if (modelsFound != -1) {
                    result = result.replace ("static_objects\\", "");
                } else {
                    modelsFound = result.indexOf("characters\\");
                    if (modelsFound == 0) {
                        charactersFound = true;
                    }
                }
            }
            if (charactersFound) {
                modelsFound = result.indexOf("assets\\");
                if (modelsFound != -1) {
                    var split = result.split("\\");                    
                    var sLength = split.length;
                    if (sLength > 2) {
                        result = "";
                        for (i = 0; i < sLength - 3; i++) {
                            result += split[i] + "\\";
                        }                        
                    }
                } else {
                    result = result.replace ("\\maps", "");
                }
            } else {
                result = result.replace ("\\maps", "");
            }
            result = "\\maps\\" + result;
        } else result = "";
        log("GetAutomaticExportPath: " + result, 1, 3);
        return result;
    }    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetFileName(mapTypeID, document)
    {
        var baseName = (document.name.split("."))[0];
        baseName = (baseName.split(app.C_SUFFIX_SEPARATOR))[0];
        var result = baseName + app.C_SUFFIX_SEPARATOR + app.ls3dDdsExportData.mapTypes[mapTypeID].suffix;
        result = result.toLowerCase();
        log("GetFileName: " + result, 1, 3);
        return result;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function FixSlashes(path)
    {
        var result = "";
        var slash = null;
        var slashType = "";
        for (var i = 0; i < path.length; i++) {
            var letter = path[i];
            if ((letter == "\\") || (letter == "/")) { 
                if (slash == null) {
                    slash = letter; 
                    slashType = letter;
                    result += letter;
                }
            } else {
                slash = null;
                result += letter;
            }
        }
        var last = result[result.length - 1];
        if ((last != "\\") && (last != "/")) { result += slashType; }
        log("FixSlashes(" + path + ") = " + result, 1, 3);
        return result;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetFilePath(filePath)
    {
        filePath.path = app.ls3DCustomData.enginePath + app.ls3DCustomData.exportPath + "\\";
        if (app.ls3DCustomData.exportPath == "") {
//            log("GetFilePath: " + filePath.path, 2, 2);
            filePath.path = "";
            return false;
        }
        filePath.path = filePath.path.toLowerCase();
        filePath.path = FixSlashes(filePath.path);
        log("GetFilePath: " + filePath.path, 1, 3);
        if ((app.ls3DCustomData.exportPath == "maps") || (app.ls3DCustomData.exportPath == "maps\\") || (app.ls3DCustomData.exportPath == "\\maps") || (app.ls3DCustomData.exportPath == "\\maps\\") ) {
            return false;
        }
        return true;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function AddDoubleSlash(path)
    {
        var splitPath = (path.split("\\"));
        var result = "";
        for (i = 0; i < splitPath.length - 1; i++) result = result + splitPath[i] + "\\\\";
        result += splitPath[splitPath.length - 1]
        log("AddDoubleSlash: " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ValidateExportPath(path, relative)
    {
        log("START: ValidateExportPath(" + path + ", " + relative + ")", 1, 3);        
        var result = "";
        path = path.toLowerCase();
        var engineFolder = GetPathInPSNotation(app.ls3DCustomData.enginePath);
        log("ValidateExportPath ------------------- ", 1, 3);
        log("   path: " + path, 1, 3);
        log("   relative: " + relative, 1, 3);
        log("   engineFolder: " + engineFolder, 1, 3);
        if (relative) {                   // relative path to edit in format:     /maps/... .
            var tempFolder = new Folder(engineFolder + path);       
            log("   tempFolder: " + tempFolder, 1, 3);
            if (!tempFolder.exists) tempFolder.create();
            result = path;
        } else {            // absolute path in PS format:          /d/!2k_games/... .
            var index = path.indexOf(engineFolder);
            if (index != -1) result = path.substr(index + engineFolder.length, path.length);
        }
        log("   result: " + result, 1, 3);        
        log("END: ValidateExportPath() = " + result, 1, 3);        
        return result;
    }    
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function NormalFlipGreenChannel(document)
    {
        log("Flipping green channel for NormalMap.", 1, 3);
        activeDocument = document;
        activeDocument.activeChannels = [activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/" + app.C_CHANNEL_NAME_GREEN + "=" + app.C_CHANNEL_NAME_GREEN))];
        var idInvr = charIDToTypeID( "Invr" );
        executeAction( idInvr, undefined, DialogModes.NO );        
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ResizeDocument(document, width, height, resampleMethod)
    {
        log("Target resolution: [" + width + "," + height + "]", 1, 3);
        // Ensure the specific document is active
        // TODO - try/except here
        var origactive = app.activeDocument;
        app.activeDocument = document;
        var resolution = document.resolution;
        document.resizeImage(width, height, resolution, resampleMethod);
        // Pop back original active doc
        app.activeDocument = origactive;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function PasteInPlace()     // paste in place from clipboard to active document
    {
        try {
            var idpast = charIDToTypeID( "past" );
            var desc557 = new ActionDescriptor();
            var idinPlace = stringIDToTypeID( "inPlace" );
            desc557.putBoolean( idinPlace, true );
            var idAntA = charIDToTypeID( "AntA" );
            var idAnnt = charIDToTypeID( "Annt" );
            var idAnno = charIDToTypeID( "Anno" );
            desc557.putEnumerated( idAntA, idAnnt, idAnno );
            executeAction( idpast, desc557, DialogModes.NO );
        } catch (e) {
            log("PasteInPlace() - There is nothing to paste.", 2, 2);            
        }
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CopySelection(copyMethod)
    {
        try {
            activeDocument.selection.copy(copyMethod);
            return true;
        } catch(e) {
            log("CopySelection(copyMethod = " + copyMethod + ") \n" + e + "\nCopy channel error. Final texture may not be correct.\nYou are probably trying to copy group without visible layer or in visible layers are no pixels.", 3, 1);
            return false;
        }        
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CopyPasteImage(document, channel, copy)
    {
        activeDocument = document;
        var savedChannels = activeDocument.activeChannels;
        var result = true;
        activeDocument.selection.selectAll();        
        if (channel != null) {
            if (channel == app.C_CHANNEL_NAME_ALPHA) {
                var alpha = activeDocument.channels.add();
                alpha.name = app.C_CHANNEL_NAME_ALPHA;                    
            }            
            activeDocument.activeChannels = [activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/" + channel + "=" + channel))]
            
            
        } else {
            // Copy the whole RGB image if channel is not specified
            channelr = activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/Red"));
            channelg = activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/Green"));
            channelb = activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/Blue"));
            activeDocument.activeChannels = [channelr, channelg, channelb];
        }    
        if (copy) {     // copy to clipboard
            result = CopySelection(false);        // copy selection
        } else {        // paste clipboard
            PasteInPlace();
            activeDocument.flatten();        
        }
        activeDocument.activeChannels = savedChannels;
        return result
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function PasteColor(document, channel, color)
    {
//        log("PasteColor() channel: " + channel + " color: " + color, 2, 2);
        activeDocument = document;
        activeDocument.selection.selectAll();
        if (channel == null) {
            log("PasteColor(), channel == null. Report this if you see it please.", 2, 2);
            // TODO??
        } else {
            if (channel == app.C_CHANNEL_NAME_ALPHA) {
                var alpha = activeDocument.channels.add();
                alpha.name = app.C_CHANNEL_NAME_ALPHA;                    
            }            
            activeDocument.activeChannels = [activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/" + channel + "=" + channel))];
            var fillColor = new SolidColor();
            var xxx = color;
            fillColor.rgb.red = color;
            fillColor.rgb.green = color;
            fillColor.rgb.blue = color;            
            activeDocument.selection.fill(fillColor);
        }            
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CopyChannel(sourceChannelType, targetChannel, sourceDocument, tempDocument)
    {
        var copyFailed = false;
        var layer = GetColapsedLayerByChannelType(sourceChannelType, sourceDocument);
        if (layer == false) return false;
        log("layer = " + layer + "       sourceChannelType = " + sourceChannelType + "      targetChannel = " + targetChannel, 1, 3);
        if (layer != null) {
            var sourceChannel = sourceChannelType.channel;
            SetLayerVisible(layer, sourceDocument);                             // unhiding collapsed layer that I want to export
            if ( CopyPasteImage(sourceDocument, sourceChannel, true) ) {
                CopyPasteImage(tempDocument, targetChannel, false);
            } else {
                copyFailed = true;
            }
        }
        if (layer == null || copyFailed) {    // there is missing group in source file that it's needed for current map type
            if (sourceChannelType.color != null ) {
                PasteColor(tempDocument, targetChannel, sourceChannelType.color);
            } else {
                log("CopyChannel() - Missing source group for channel: " + targetChannel + " and default color not found in configuration. Unable to continue.", 3, 1);
                return false;
            }
        }
        return true;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CopyArea(sourceDocument, targetDocument, area, alpha)
    {
        log("START: CopyArea(" + sourceDocument + ", " + targetDocument + ", " + area + ", " + alpha + ")", 1, 3);        
        var region = [[area.x1, area.y1], [area.x2, area.y1], [area.x2, area.y2], [area.x1, area.y2]];
        var copyMethod = true;
        activeDocument = sourceDocument;
        if (activeDocument.layers.length == 1) copyMethod = false;
        try {
            if (alpha) {
                channel = app.C_CHANNEL_NAME_ALPHA;
                copyMethod = false;
                    activeDocument.activeChannels = [activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/"+channel+"="+channel))];
            } else {
                channel = "RGB";
                SelectChannel(channel);
            }
        } catch (e) {
            log("Unable to find channel: " + channel.toString() + " to copy. " + e.toString(), 3, 1);
            log("END: CopyArea()", 1, 3);
            return false;
        }
        activeDocument.selection.select(region);
        CopySelection(copyMethod);          // copy selection
        activeDocument = targetDocument;
        try {
            if (alpha) {
                var alpha = activeDocument.channels.add();
                channel = app.C_CHANNEL_NAME_ALPHA;
                activeDocument.activeChannels = [activeDocument.channels.getByName(localize("$$$/ColorModes/RGB/ChannelName/"+channel+"="+channel))];
            } else {
                channel = "RGB";
                SelectChannel(channel);
            }
        } catch (e) {
            log("Unable to find channel: " + channel.toString() + " to paste. " + e.toString(), 3, 1);
            log("END: CopyArea()", 1, 3);
            return false;
        }
        activeDocument.paste(false);
        log("END: CopyArea()", 1, 3);
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateTempDocument(filename)
    {
        var newDocument = app.documents.add(activeDocument.width, activeDocument.height, activeDocument.resolution, filename, NewDocumentMode.RGB);
        return  newDocument;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateTempSizedDocument(filename, width, height)
    {
        var newDocument = app.documents.add(width, height, activeDocument.resolution, filename, NewDocumentMode.RGB);
        return  newDocument;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function OpenDocument(path)
    {
        try {
            var fileRef = new File(AddDoubleSlash(path))
            var docRef = app.open(fileRef)
        } catch(e) { 
            log("Unable to open " + path, 3, 1); 
            log(e, 2, 1);
        }
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CloseAllDocuments()
    {
        var appDoc = app.documents;
        for (var i = 0; i < appDoc.length; i++) {
            log("Closing PSD document: " + appDoc[i].name, 1, 3);
            appDoc[i].close(SaveOptions.DONOTSAVECHANGES);
        }
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SaveDocument(document, path, type, alpha)
    {
        log("START: SaveDocument(" + document + ", " + path + ", " + type + ", " + alpha + ")", 1, 3);        
        app.displayDialogs = DialogModes.NO;
        activeDocument = document;
        var options;
        if (type == "PSD") {
            options = new PhotoshopSaveOptions();
            options.alphaChannels = alpha;
            options.embedColorProfile = true;
            options.layers = true;
        }
        if (type == "TGA") {
            options = new TargaSaveOptions();
            options.resolution = TargaBitsPerPixels.THIRTYTWO;
            options.alphaChannels = alpha;
            options.rleCompression = false;
        }
        var file = new File(path);
        log("SaveDocument path: " + path, 1, 3);
        var tempFolder = file.parent;
        if (!tempFolder.exists) tempFolder.create();
        try {
            activeDocument.saveAs(file, options, false, Extension.LOWERCASE);
        } catch (e) {
            app.displayDialogs = DialogModes.ERROR;
            log("File " + file + " was not saved\n" + e, 3, 1);
            log("END: SaveDocument() = false", 1, 3);        
            return false;
        }
        app.displayDialogs = DialogModes.ERROR;
        log("END: SaveDocument() = true", 1, 3);        
        return true;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GenerateMipTextures(tempDocument, baseName, customMipmapsInfo)
    {
        log("START: GenerateMipTextures(" + tempDocument + ", " + baseName + ", " + customMipmapsInfo + ")", 1, 3);        
        var area = {
            x1: 0,
            x2: 0,
            y1: 0,
            y2: 0
        }
        var baseMipIndex = 0;
        var lessMipmap = false;
        for (i = 1; i < C_RESOLUTIONS.length; i++) {
            if (C_RESOLUTIONS[i] == customMipmapsInfo.width) baseMipIndex = i;
        }
        var height = tempDocument.height;
        var width = tempDocument.width;
        log("Base map size = [" + customMipmapsInfo.width + "," + height + "]", 1, 3);
        var result = Array();
        log("Base map name: " + baseName, 1, 3);
        log("customMipmapsCount: " + customMipmapsInfo.count, 1, 3);
        var xOffset = 0;
        area.y2 = Number(tempDocument.height);
        var suffixIndex = 0;
        for(i = baseMipIndex; i >= 0; i--) {
            var suffix = "_";
            if (suffixIndex < 10) suffix += "0";
            suffix += suffixIndex;
            
            var temp = 1;
            if (i > 0) temp = C_RESOLUTIONS[i];
            
            area.x1 = xOffset;
            area.x2 = xOffset + temp;
            if (area.x2 <= width) {
                log("Area " + suffix + " [" + area.x1 + "," + area.y1 + "] [" + area.x2 + "," + area.y2 + "]   Texture size: [" + (area.x2 - area.x1) + "," + (area.y2 - area.y1) + "]", 1, 3);
                
                var newTemp = CreateTempSizedDocument(baseName + suffix + app.C_FILE_EXTENSION_SOURCE, (area.x2 - area.x1), (area.y2 - area.y1));
                result[suffixIndex] = newTemp;
                
                CopyArea(tempDocument, newTemp, area, false);
                try {
                    var alphaChannel = currentDocument.channels.getByName(app.C_CHANNEL_NAME_ALPHA);
                    CopyArea(tempDocument, newTemp, area, true);
                } catch (e) {} // no alpha so I'm skipping the copy
                
            } else lessMipmap = true;
            xOffset += temp;
            area.y2 = area.y2 / 2;
            suffixIndex += 1;
        }
        if (!lessMipmap) {
            while (area.y2 >= 1) {
                var suffix = "_";
                if (suffixIndex < 10) suffix += "0";
                suffix += suffixIndex;
                
                var temp = 1;
                area.x1 = xOffset;
                area.x2 = xOffset + temp;
                log("Area " + suffix + " [" + area.x1 + "," + area.y1 + "] [" + area.x2 + "," + area.y2 + "]   Texture size: [" + (area.x2 - area.x1) + "," + (area.y2 - area.y1) + "]", 1, 3);
                
                var newTemp = CreateTempSizedDocument(baseName + suffix + app.C_FILE_EXTENSION_SOURCE, (area.x2 - area.x1), (area.y2 - area.y1));
                result[suffixIndex] = newTemp;
                
                CopyArea(tempDocument, newTemp, area, false);
                try {
                    var alphaChannel = currentDocument.channels.getByName(app.C_CHANNEL_NAME_ALPHA);
                    CopyArea(tempDocument, newTemp, area, true);
                } catch (e) {} // no alpha so I'm skipping the copy
                
                xOffset += temp;
                area.y2 = area.y2 / 2;
                suffixIndex += 1;
            }
        }
        log("END: GenerateMipTextures() = " + result, 1, 3);    
        return result;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function SaveMipDocuments(mipDocuments, tempPSD, arguments, formatScale, scaleFilter, localExport, enableP4)
    {
        log("START: SaveMipDocuments(" + mipDocuments + ", " + tempPSD + ", " + arguments + ", " + formatScale + ", " + scaleFilter + ", " + localExport + ", " + enableP4 + ")", 1, 3);
        log("SaveMipDocuments.length: " + mipDocuments.length + "  TempPSD: " + tempPSD, 1, 4);
        log("BaseArguments: " + arguments, 1, 4);
        var tempPaths = new Array();
        for (var i = 0; i < mipDocuments.length; i++) {
            var suffix = "_";
            if (i < 10) suffix += "0";
            suffix += i.toString();
            var sourcePath = tempPSD + suffix + app.C_FILE_EXTENSION_SOURCE;
            var ddsPath = tempPSD + suffix + app.C_FILE_EXTENSION_EXPORT;
            var workDocument = mipDocuments[i];
            if (!SaveDocument(workDocument, sourcePath, C_TEMP_FORMAT_TYPE, true)) return false;
            $.sleep(200);
            
            var scale = C_NUMERIC_SCALES[formatScale];
            var wait = Math.round((workDocument.width * workDocument.height * scale) / 1000);
            log("SCALE: " + scale + "   original width: " + workDocument.width, 1, 3);
            var skip = false;
            if (scale != 1) {
                var finalWidth = scale * Number(workDocument.width);
                log("Final Width = " + finalWidth, 1, 3);
                if (finalWidth < 1) {
                    log("Image size is less than 1px, skipping this mipmap.", 1, 3);
                    skip = true;
                } else {
                    var gamma = "2.2";
                    var filter = scaleFilter;
                    RescaleSource(sourcePath, scale, gamma, filter, wait);
                }
            }
            if (!skip) {
                var arg = arguments + " \"" + sourcePath + "\" \"" + ddsPath + "\"";
                log("Export argumets: " + arguments + "    Waiting for " + wait + "ms", 1, 3);
                RunExternalDDSCompressor("\"" + app.C_NVIDIA_TOOLS_2_PATH + "\"", arg, ddsPath, sourcePath, false, wait);
    //            $.sleep(wait);
                tempPaths.push(ddsPath);
            }
        }
        var mipLength = mipDocuments.length;
        if (mipLength > 0) {
            for (var i = mipLength - 1; i >= 0; i--) {
                var workDocument = mipDocuments[i];
                workDocument.close(SaveOptions.DONOTSAVECHANGES);
                mipDocuments[i] = null;
            }
            UpdateWipDialog(5, "Saving DDS", false);
            RunMipmapStitch("\"" + app.C_NVIDIA_STITCH_PATH + "\"", tempPSD, mipDocuments.length, enableP4);
            
            for (var i = 1; i < tempPaths.length; i++) {
                if (app.C_DELETE_TEMP_FILES) DeleteFileFromDLL(tempPaths[i]);
            }
        }
        log("END: SaveMipDocuments()", 1, 3);
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RescaleSource(file, scale, gamma, filter, wait)
    {
        log("START: RescaleSource(" + file + ", " + scale + ", " + gamma + ", " + filter + ", " + wait + ")", 1, 3);
        var arguments = " -s " + scale;
        arguments += " -g " + gamma;
        arguments += " -f " + filter;
        arguments += " \"" + file + "\" \"" + file + "\"";
        log("Rescale image arguments: " + arguments + "    Waiting for " + wait + "ms", 1, 3);
        if (app.EXTERNAL_OBJECT == null) { 
            RunExternalProcess("\"" + app.C_NVIDIA_TOOLS_2_SCALE_PATH + "\"", arguments);
            $.sleep(2 * wait);
        } else {
            RunExternalProcessFromDLL(app.C_NVIDIA_TOOLS_2_SCALE_PATH, arguments);
        }
        log("END: RescaleSource()", 1, 3);        
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Texture2DResolutionTest(size)
    {
        var result = false;
        for (var i = 1; i < C_RESOLUTIONS.length; i++) {
            if (size == C_RESOLUTIONS[i]) result = true;
        }
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function TextureCubeResolutionTest(x, y)
    {
        if (Texture2DResolutionTest(y)) {
            if (x == 6 * y) return true;
        }
        return false;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GenerateCubeTextures(compressionParams)
    {
        var result = Array();
        var width = compressionParams.width;
        var height = compressionParams.height;
        var targetDDSPath = compressionParams.outPath;
        var currentDocument = activeDocument;
        var area = {
            x1: 0,
            x2: 0,
            y1: 0,
            y2: 0
        }        
        for (var i = 0; i < 6; i++) {
            var docFileName = GetCubeFileName(compressionParams.outFile, i);
            var newDocument = CreateTempSizedDocument(docFileName, width, height);
            var targetFile = targetDDSPath + docFileName;
            
            area.x1 = (width * i);
            area.x2 = (width * (i + 1));
            area.y1 = 0;
            area.y2 = height;
            
            CopyArea(currentDocument, newDocument, area, false);
            try {
                var alphaChannel = currentDocument.channels.getByName(app.C_CHANNEL_NAME_ALPHA);
                CopyArea(currentDocument, newDocument, area, true);
            } catch (e) {} // no alpha so I'm skipping the copy
            
            SaveDocument(newDocument, targetFile, "TGA", true);            
            result.push(newDocument);
        }    
        activeDocument = currentDocument;
                    //CreateTempSizedDocument
            //CopyArea
            //SaveDocument
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GenerateMipResolutions(width, height)
    {
        log("START: GenerateMipResolutions(" + width + ", " + height + ")", 1, 3);        
        var maxIndex = 99;
        var minIndex = 99;
        for (var i = 1; i < C_RESOLUTIONS.length; i++) {
            if (C_RESOLUTIONS[i] <= width) maxIndex = i;
            if (C_RESOLUTIONS[i] <= width / 3) minIndex = i;
        }
        var result = Array();
        log("minRes = " + C_RESOLUTIONS[minIndex].toString() + ", maxRes = " + C_RESOLUTIONS[maxIndex].toString(), 1, 3);
        for (var i = minIndex; i <= maxIndex; i++) {
            var temp = C_RESOLUTIONS[i];
            var subArray = Array();
            var index = 0;
            var tempHeight = height;
            subArray[index] = temp;
            for (var j = i - 1; j > 0; j--) {
                tempHeight = tempHeight / 2;
                index += 1;
                temp += C_RESOLUTIONS[j];
                subArray[index] = temp;
            }
            log("remaining tempHeight = " + tempHeight.toString(), 1, 3);
            log("Index = " + i + ", subArray = " + subArray.toString(), 1, 3);
            while (tempHeight > 1) {
                index += 1;
                tempHeight = tempHeight / 2;
                temp += 1;
                subArray[index] = temp;
            }
            result[i - minIndex] = subArray;
            log("Index = " + i + ", subArray = " + subArray.toString(), 1, 3);
        }
        log("END: GenerateMipResolutions() = " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function TextureCustomMipmapsResolutionTest(width, height, customMipmapsInfo)
    {
        log("START: TextureCustomMipmapsResolutionTest(" + width + ", " + height + ", " + customMipmapsInfo + ")", 1, 3);
        var result = Texture2DResolutionTest(height);
        var textureResolution = 0;
        log("Correct height resolution: " + result, 1, 4);
        if (result) {
            result = false;
            var resolutions = GenerateMipResolutions(width, height);
            for (var i = 0; i < resolutions.length; i++) {
//                log("--------", 1, 4);
                for (var j = 0; j < resolutions[i].length; j++) {
//                    log("Resolutions: " + resolutions[i][j], 1, 4);
                    if (resolutions[i][j] == width) {
//                        log("Found. [" + i + "," + j + "]", 1, 4);
                        result = true;
                        textureResolution = resolutions[i][0];
                        customMipmapsInfo.count = j;
                        
                        log("Base width resolution = " + textureResolution, 1, 3);
                        customMipmapsInfo.width = textureResolution;
                        log("END: TextureCustomMipmapsResolutionTest() = " + result, 1, 3);
                        return result;
                    }
                }
            }
        }    
        log("Base width resolution = " + textureResolution, 1, 3);
        customMipmapsInfo.width = textureResolution;
        log("END: TextureCustomMipmapsResolutionTest() = " + result, 1, 3);
        return result;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function DuplicateDocument(originalDocument)
    {
        log("START: DuplicateDocument(" + originalDocument + ")", 1, 3);
        var tempName = "temp.psd";
        log("Duplicating document " + originalDocument.name + " -> " + tempName, 1, 3);
        var duplicate = originalDocument.duplicate(tempName);
        log("END: DuplicateDocument() = " + duplicate, 1, 3);
        return duplicate;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CheckSelectedLayer(myLayer)
    {
        log("START: CheckSelectedLayer(" + myLayer + ")", 1, 3);
        if (!myLayer.typename.match("LayerSet")) {                              // if selected layer is group
            log("You have to select layer GROUP you want to export.", 3, 1);                   
            return -1; 
        }
        if (!myLayer.parent.typename == "Document") {                           // if selected group is the most parent
            log("You have to select the most parent group.", 3, 1);                            
            return -1; 
        }
        var selectedGroupID = FindGroupTypeIDByName(myLayer.name);
        
        if (selectedGroupID == -1) {                                            // if selected group has correct name
            log("Unknown name of selected group. You have to follow naming rules.", 3, 1);     
            return -1; 
        }
        log("Everything Ok.", 1, 3);
        log("END: CheckSelectedLayer() = " + selectedGroupID, 1, 3);
        return selectedGroupID;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function DuplicateLayerToNewDocument(originalDocument, duplicatedOriginal, mapTypeID, localExport, layer)
    {
        function fileinfo()
        {
            this.tempDocument = "";
            this.tempPSD = "";
            this.targetDDS = "";
            this.targetDDSPath = "";
            this.fileName = "";
            this.isNormalMap = false;
            this.hasAlpha = false;
        }
    
        try {
            var fileName = GetFileName(mapTypeID, originalDocument);
            var tempDocument = CreateTempDocument(fileName);
            
            // If layer is defined, duplicate that, instead of doing per-channel copies
            if ((layer != undefined) && (layer != null))
            {
                UpdateWipDialog(5, "Duplicating all channels... ", false);                
                DuplicateLayer(duplicatedOriginal, tempDocument, layer);
            }
            else
            {
                UpdateWipDialog(5, "Copying channels... red", false);
                CopyChannel(app.ls3dDdsExportData.mapTypes[mapTypeID].red, app.C_CHANNEL_NAME_RED, duplicatedOriginal, tempDocument);
                UpdateWipDialog(5, "Copying channels... green", false);
                CopyChannel(app.ls3dDdsExportData.mapTypes[mapTypeID].green, app.C_CHANNEL_NAME_GREEN, duplicatedOriginal, tempDocument);
                UpdateWipDialog(5, "Copying channels... blue", false);
                CopyChannel(app.ls3dDdsExportData.mapTypes[mapTypeID].blue, app.C_CHANNEL_NAME_BLUE, duplicatedOriginal, tempDocument);
                UpdateWipDialog(5, "Copying channels... alpha", false);
                CopyChannel(app.ls3dDdsExportData.mapTypes[mapTypeID].alpha, app.C_CHANNEL_NAME_ALPHA, duplicatedOriginal, tempDocument);
            }
        } catch (e) {
            log("Error while copying channels. \n" + e, 3, 1);
            UpdateWipDialog(99, "Channel copy error", true);
            tempDocument.close(SaveOptions.DONOTSAVECHANGES);
            log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);
            return null;
        }
        var myFormat;
        if (mapTypeID < app.ls3DCustomData.formats.length) {
            myFormat = app.ls3DCustomData.formats[mapTypeID];
            log("mapTypeID: " + mapTypeID + " format.name: " + myFormat.name, 1, 3);
        } else {
            log("ERROR: Wrong mapTypeID found: " + mapTypeID + " Please open UI confluguration dialog and click on 'Save changes' button.", 3, 1);
            UpdateWipDialog(99, "Channel copy error", true);
            tempDocument.close(SaveOptions.DONOTSAVECHANGES);
            log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);
            return null;
        }        
    
        // !!! hardcoded normal map names !!!
        var isNormalMap = ((myFormat.name == C_NORMALMAP_NAMES[0]) || (myFormat.name == C_NORMALMAP_NAMES[1]));
        //var exportFormat = " -" + Compress_TexTools2_ConvertExportFormat(app.ls3dDdsExportData.mapTypes[mapTypeID].formats[currentFormat], isNormalMap);    // format
        var flipNormalGreen = false;
        var hasAlpha = (myFormat.ddsFormat == 1);
        if (isNormalMap) { 
            //exportFormat += " -normal";               // removed because corrupted NM when there is some other texture inside - occlusion in blue channel
            flipNormalGreen = ((app.C_DEBUG_FLIP_NORMAL) && (!app.C_PERFORCE_ENABLED));
        }
        if (flipNormalGreen) {
            NormalFlipGreenChannel(tempDocument);
        }
    
        // Setup the output struct
        var output = new fileinfo();
        output.fileName = fileName;
        output.tempDocument = tempDocument;
        output.isNormalMap = isNormalMap;
        output.hasAlpha = hasAlpha;
                
        // Compute the output filename
        var filePathObject = { path:"" };
        var filePathResult = GetFilePath(filePathObject);
        if (!filePathResult) {
            if (filePathObject.path == "") {
                log("DDS file path is not correct. Canceling export.", 3, 1);
                tempDocument.close(SaveOptions.DONOTSAVECHANGES);
                RestoreLayerVisibility(originalDocument);
                log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);
                return false;
            } else {
                log("DDS file path is set directly to edit/maps/. That looks like an error, please verify. Export continues.", 3, 1);
            }
        }
        var filePath = filePathObject.path;
        if (localExport) {
            try {
                output.tempPSD = GetPathInWinNotation(originalDocument.path) + "\\";                                // source file
                output.targetDDS = GetPathInWinNotation(originalDocument.path) + "\\";                              // target dds
                output.targetDDSPath = targetDDS;
            } catch (e) {
                log("You must save your PSD first.", 3, 1);
                tempDocument.close(SaveOptions.DONOTSAVECHANGES);
                RestoreLayerVisibility(originalDocument);
                app.activeDocument.activeLayer = selectedLayerBackup;       // restore originaly active layer
                log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);
                return false;
            }
        } else {
            output.tempPSD = filePath;                                 // source file
            output.targetDDS = filePath;                               // target dds
            output.targetDDSPath = filePath;                           // target dds path
        }
        return output;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ValidateMapIDs(inMapIDArray)
    {
        var mapTypeIDArray = new Array();
        for (var i = 0; i < inMapIDArray.length; i++) 
        {
            // Check for buffer overflows in app.ls3dCustomData.formats.
            //  swat_truck_in.psd@07/23/2015 had this issue.
            if (inMapIDArray[i] >= app.ls3DCustomData.formats.length)
            {
                log("MapID " + inMapIDArray[i] + " exceeds the number if formats in app.ls3dCustomData.formats (" + app.ls3DCustomData.formats.length-1 + ")", 2, 2);
                continue;
            }
        
            if (app.ls3DCustomData.formats[inMapIDArray[i]].disabled == 0) 
            {
                mapTypeIDArray.push(inMapIDArray[i]);
            }
        }
        if (mapTypeIDArray.length > 1) {
            log("Multiple groups with the same name in configuration. This is not supported. Trying to regenerate settings and restart export.", 2, 1);
            return -1;
        }
        else if (mapTypeIDArray.length == 0) {
            log("Unable to determine any map types. Current configuration is invalid. Try regenerating the settings and restart the export.", 2, 1);
            return -1;
        }
        else
            return mapTypeIDArray[0];
    }

}
//--------- /END LAYER FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------

//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- EXPORT FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ExportSelectedLayer(originalDocument, duplicatedOriginal, mapTypeID, localExport, enableP4, hdVersion)
    {
        log("START: ExportSelectedLayer( localExport = " + localExport + ", enableP4 = " + enableP4 + ", " + hdVersion + " )", 1, 3);
        log("Exporting selected layer: " + originalDocument.activeLayer.name, 1, 3);
        UpdateWipDialog(60, "Copying channels", true);
        
        // Copy/Duplicatae the layer to a new document
        var fileInfo = DuplicateLayerToNewDocument(originalDocument, duplicatedOriginal, mapTypeID, localExport, null);
        if (fileInfo == null) {
            return false;
        }
        var tempDocument = fileInfo.tempDocument;
        var myFormat = app.ls3DCustomData.formats[mapTypeID];

        UpdateWipDialog(5, "Collecting export arguments", false);
        var fileName = fileInfo.fileName;
        var filePathObject = { path:"" };
        var filePathResult = GetFilePath(filePathObject);
        if (!filePathResult) {
            if (filePathObject.path == "") {
                log("DDS file path is not correct. Canceling export.", 3, 1);
                tempDocument.close(SaveOptions.DONOTSAVECHANGES);
                RestoreLayerVisibility(originalDocument);
                log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);
                return false;
            } else {
                log("DDS file path is set directly to edit/maps/. That looks like an error, please verify. Export continues.", 3, 1);
            }
        }
    
    
        var profileIndex = GetProfileIndexByName(app.ls3DCustomData.profile);
        var nodds = false;
        if (profileIndex != -1) nodds = app.ls3dUserMapTypes.userMapList[profileIndex].nodds;
    
        var filePath = filePathObject.path;        
        var currentFormat = myFormat.ddsFormat;

        var tempPSD = fileInfo.tempPSD;
        var targetDDS = fileInfo.targetDDS;
        var targetDDSPath = fileInfo.targetDDSPath;
        
        app.ls3dCompressorParams.inPath = tempPSD;
        app.ls3dCompressorParams.inFile = fileName;
        app.ls3dCompressorParams.inType = app.C_FILE_EXTENSION_SOURCE;
        app.ls3dCompressorParams.outPath = targetDDSPath;
        app.ls3dCompressorParams.outFile = fileName;
        app.ls3dCompressorParams.outType = app.C_FILE_EXTENSION_EXPORT;
        app.ls3dCompressorParams.mipCount = myFormat.mipmaps;
        app.ls3dCompressorParams.format = app.ls3dDdsExportData.mapTypes[mapTypeID].formats[currentFormat];
        app.ls3dCompressorParams.filter = "";               // filter for compressor side resizing
        app.ls3dCompressorParams.customMips = myFormat.customMipmaps;
        app.ls3dCompressorParams.cubemap = myFormat.cubemap;
        app.ls3dCompressorParams.isNormalMap = fileInfo.isNormalMap;   // TODO: recognize texture where is only NM
        app.ls3dCompressorParams.hasAlpha = fileInfo.hasAlpha;
        app.ls3dCompressorParams.force_compressor = app.ls3dDdsExportData.mapTypes[mapTypeID].defaults.force_compressor;
        app.ls3dCompressorParams.nodds = nodds;
        
        
        tempPSD += fileName + app.C_FILE_EXTENSION_SOURCE;                                  // source file
        targetDDS += fileName + app.C_FILE_EXTENSION_EXPORT;                                // target dds
        
        if (nodds) {
            tempPSD = originalDocument.path + fileName + app.C_FILE_EXTENSION_SOURCE;
        }
        
        log("tempPSD = " + tempPSD, 1, 3);
        log("targetDDS = " + targetDDS, 1, 3);
        
        // Process any layers that are "required"
        // TODO - right now, the are "defaults" with no way for the user to override them
        var required = app.ls3dDdsExportData.mapTypes[mapTypeID].defaults.requires;
        var tmpOpenFiles = new Array();
        // Push the main temp file onto the stack, then create/push requirements
        // Pushing back the file-info part of it so all the relative data regarding document,
        // paths etc. are there
        tmpOpenFiles.push(fileInfo);
        for (var i=0; i < required.length; i++)
        {
            log("Processing requirement: " + required[i], 1, 3);

            // Split by the pipe in the case that multiple groups could be considered for a single
            // requirement (GT_NORMAL or GT_NORMAL5)
            var reqGroupID = -1
            var layerGroup = null;
            var possibleGroups = required[i].split('|');
            for (var j=0; j < possibleGroups.length; j++)
            {
                reqGroupID = FindGroupTypeIDByType(possibleGroups[j]);
                layerGroup = FindCollapsedLayerByType(app.ls3dDdsExportData.groupTypes[reqGroupID], duplicatedOriginal);
                if (layerGroup != null)
                    break;
            }
            //return false;
            
            // Validate we found a group 
            if (reqGroupID == -1)
            {
                log("Unable to determine group ID from requirement: " + required[i], 3, 1);
                return false;
            }
        
            // Validate we found a layer
            if (layerGroup == null)
            {
                // Warn user, but continue
                log("Unable to find corresponding layer group from requirement: " + required[i], 2, 1);
                continue;
            }
        
            // Determine the mapType from the groupID
            var reqMapTypeArray = FindMapTypeIDByGroupID(reqGroupID);
            var reqMapType = ValidateMapIDs(reqMapTypeArray);

            // Call this function again
            if (reqMapType == -1)
            {
                // Warn user but continue
                log("Cannot determine the mapTypeID from requirement: " + required[i], 2, 1);
                continue;
            }
        
            // Hack - ignore the color channel stuff in the config here, and just copy the layer
            var result = DuplicateLayerToNewDocument(originalDocument, duplicatedOriginal, reqMapType, localExport, layerGroup);
            if (result == null)
            {
                log("Unable to duplicate layer: " + layerGroup, 2, 1);
                return false;
            }

            tmpOpenFiles.push(result);
        }
                
        UpdateWipDialog(5, "Resizing image", false);
        if (!myFormat.customMipmaps) {
            var scale = C_NUMERIC_SCALES[myFormat.scale];
            var resampleMethod = ResampleMethod.BICUBICSHARPER;
            switch (myFormat.filter)
            {
                case (0):
                    resampleMethod = ResampleMethod.BICUBICSHARPER;
                    break;
                case (1):
                    resampleMethod = ResampleMethod.BILINEAR;
                    break;
                case (2):
                    resampleMethod = ResampleMethod.BICUBIC;
                    break;
                case (3):
                    resampleMethod = ResampleMethod.NEARESTNEIGHBOR;
                    break;
                case (4):
                    resampleMethod = ResampleMethod.BICUBICSMOOTHER;
                    break;
            }
            if ((myFormat.resolutionX != 0) || (myFormat.resolutionY != 0)) {
                
                targetResolutResampleMethodResampleMethodionX = originalDocument.width.value;
                if (myFormat.resolutionX != 0) targetResolutionX = Number(C_RESOLUTIONS[myFormat.resolutionX]);
                targetResolutionY = originalDocument.height.value;
                if (myFormat.resolutionY != 0) targetResolutionY = Number(C_RESOLUTIONS[myFormat.resolutionY]);
                
                if (hdVersion == true) {    // support for hd version of resized textures
                    if (targetResolutionX < originalDocument.width.value) {                        
                        targetResolutionX = targetResolutionX * 2;
                    }
                    if (targetResolutionY < originalDocument.height.value) {    
                        targetResolutionY = targetResolutionY * 2;
                    }
                }
                if ((targetResolutionX != originalDocument.width.value) || (targetResolutionY != originalDocument.height.value)) {
                    // Resize requirements
                    // TODO - maybe should add an option to link the sizes or not. In the case of variance, they need to be linked.
                    for (var i = 0; i < tmpOpenFiles.length; i++)
                    {
                        ResizeDocument(tmpOpenFiles[i].tempDocument, targetResolutionX, targetResolutionY, resampleMethod);
                    }
                }
            } else {
                if ((hdVersion == true) && (scale < 1)) {           // support for hd version of scaled textures
                    scale = scale * 2;
                } 
                if (scale != 1) {

                    if (scale != 1) {
                        log("SCALE: " + scale + "   original size: [" + originalDocument.width.value + "," + originalDocument.height.value + "]", 1, 3);
                        targetResolutionX = originalDocument.width.value * scale;
                        targetResolutionY = originalDocument.height.value * scale;
                                      
                        // Resize
                        // TODO - maybe should add an option to link the sizes or not. In the case of variance, they need to be linked.
                        for (var i = 0; i < tmpOpenFiles.length; i++)
                        {
                            ResizeDocument(tmpOpenFiles[i].tempDocument, targetResolutionX, targetResolutionY, resampleMethod);
                        }
                    }
                }
            }
        }
        
    
    
        app.ls3dCompressorParams.width = tempDocument.width.value;
        app.ls3dCompressorParams.height = tempDocument.height.value;

        UpdateWipDialog(5, "Testing resolution", false);
        var customMipmapsInfo = {                       // base width for texture with custom mipmaps
            width: 0,
            count: 0
        }

        if (myFormat.cubemap) {
            if (!TextureCubeResolutionTest(tempDocument.width.value, tempDocument.height.value)) { 
                log("This image resolution is not allowed for dds cubemap.", 3, 1);     
                tempDocument.close(SaveOptions.DONOTSAVECHANGES);   
                RestoreLayerVisibility(originalDocument);   
                return false; 
            } else {
                app.ls3dCompressorParams.width /= 6;    // setting real width of one image
            }
        } else {
            if((myFormat.resolutionX == 0) || (myFormat.resolutionY == 0)) {
                if (myFormat.customMipmaps) {
                    var result = TextureCustomMipmapsResolutionTest(tempDocument.width.value, tempDocument.height.value, customMipmapsInfo);
                    if (result == false) { 
                        log("This image resolution is not allowed for dds with custom mipmaps.", 3, 1);     
                        tempDocument.close(SaveOptions.DONOTSAVECHANGES);   
                        RestoreLayerVisibility(originalDocument);   
                        return false; 
                    }
                } else {
                    log("Document resolution: [" + tempDocument.width.value + tempDocument.width.type + ", "+ tempDocument.height.value + tempDocument.height.type + "]", 1, 3);
                    if (!Texture2DResolutionTest(tempDocument.width.value))  { 
                        log("Image width is not power of two. That's now allowed for dds format.", 3, 1);       
                        RestoreLayerVisibility(originalDocument);   
                        tempDocument.close(SaveOptions.DONOTSAVECHANGES);   
                        return false; 
                    }
                    if (!Texture2DResolutionTest(tempDocument.height.value)) { 
                        log("Image height is not power of two. That's now allowed for dds format.", 3, 1);      
                        RestoreLayerVisibility(originalDocument);   
                        tempDocument.close(SaveOptions.DONOTSAVECHANGES);   
                        return false; 
                    }
                }
            } else {
                if (myFormat.customMipmaps) {
                    //TODO: It would be good to add support for custom mipmap with custom ressolution.
                    log("Custom mipmaps with custom ressolution is not supported functionality. Please use resolution SCALE instead. Layer Type = " + myFormat.name, 3, 1);
                }
            }
        }
        
        var quality = " -" + C_QUALITY[myFormat.quality];                                                 // quality
        var sharpening = " -sharpenMethod " + C_SHARPENING[C_F_DEFAULT_SHARPENING];                          // sharpening
        if (myFormat.customMipmaps) {                                                                     // custom mipmaps
            if (customMipmapsInfo.width != 0) {
                UpdateWipDialog(5, "Generating Mipmap textures", false);
                var mipDocuments = GenerateMipTextures(tempDocument, (fileName), customMipmapsInfo);
                var exportFormat = "";  //TODO!!!
                var arguments = exportFormat + " -nomips";
                UpdateWipDialog(5, "Saving Mipmap textures", false);
                SaveMipDocuments(mipDocuments, (filePath + fileName), arguments, myFormat.scale, C_SCALE_FILTER[myFormat.scaleFilter], localExport, enableP4);
            }
        } else {
            UpdateWipDialog(5, "Saving temp TGA", false);
//            var source = filePath + fileName + app.C_FILE_EXTENSION_SOURCE;

            // Save the temp documents
            for (var i = 0; i < tmpOpenFiles.length; i++)
            {
                // Save as a tga
                var documentToSave = tmpOpenFiles[i].tempDocument;
                var targetPath = tmpOpenFiles[i].tempPSD + tmpOpenFiles[i].fileName;
                
                if (nodds) {
                    targetPath = originalDocument.path + "/" + tmpOpenFiles[i].fileName;
                }
            
                if (!SaveDocument(documentToSave, targetPath, C_TEMP_FORMAT_TYPE, true)) 
                {
                    tmpOpenFiles[i].tempDocument.close(SaveOptions.DONOTSAVECHANGES);
                    log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);
                    return false;
                }
            
                // Push the temp document name into the requires list for this export. Assume the first
                // element is the main file. so only push requirements past 1
                if (i > 0)
                {
                    app.ls3dCompressorParams.requires.push(tmpOpenFiles[i].tempDocument.fullName.fsName);
                }
            }
        
            var nMipMaps = "";                                                                          // mipmaps
            var exportDone = false;
            var wait = Math.round((tempDocument.width * tempDocument.height) / 1000);
                            
            // Pick the external compressor and process it.
            PickExternalCompressor(app.C_SELECTED_COMPRESSOR_INDEX, enableP4, wait);
        }
        UpdateWipDialog(99, "Cleaning data", true);
        for (var i = 0; i < tmpOpenFiles.length; i++)
        {
            tmpOpenFiles[i].tempDocument.close(SaveOptions.DONOTSAVECHANGES);
        }
        log("END: ExportSelectedLayer( localExport = " + localExport + " ) = true", 1, 3);
        log("....................................................................", 1, 3);
        log("....................................................................", 1, 3);        
        return true;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ExportAllLayers(originalDocument, duplicatedOriginal, localExport, enableP4, hdVersion)
    {
        log("START: ExportAllLayers(" + originalDocument + ", " + duplicatedOriginal + ", " + localExport + ")", 1, 3);
        var document = duplicatedOriginal;
        var exportedMapTypes = new Array();
        for (var layerIndex = 0; layerIndex < app.CACHE_CollapsedArtLayerNames.length; layerIndex++) {
            var layer = document.artLayers[layerIndex];
            app.selectedLayer = layer;
            var selectedGroupID = FindGroupTypeIDByName(app.CACHE_CollapsedArtLayerNames[layerIndex]);
            var tempMapTypeIDArray = FindMapTypeIDByGroupID(selectedGroupID); 
            if (tempMapTypeIDArray.length > 0) {
                var mapTypeID = ValidateMapIDs(tempMapTypeIDArray);
                
                if (mapTypeID == -1)
                {
                    break;
                }                
                
                // TODO: FindMapTypeIDByGroupID muze vratit pole pokud najde vic moznosti, ale tady se s tim zachazi jako s cislem. Muze delat problemy.
                var alreadyExported = false;
                for (var i = 0; i < exportedMapTypes.length; i++) {
                    if (mapTypeID == exportedMapTypes[i]) alreadyExported = true;
                }
                if (!alreadyExported) {
                    log("Single Layer export START.", 1, 3);
                    log("Layer name: " + app.CACHE_CollapsedArtLayerNames[layerIndex], 1, 3);
                    exportedMapTypes.push(mapTypeID);
                    ExportSelectedLayer(originalDocument, duplicatedOriginal, mapTypeID, localExport, enableP4, hdVersion);        
                }
            } else {
                log("Layer you are trying to export is not enabled in UI. Change presset in configuration.", 3, 1);
            }
        }
        log("END: ExportAllLayers(" + originalDocument + ", " + duplicatedOriginal + ", " + localExport + ")", 1, 3);
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Export(localExport, exportAll, enableP4, hdVersion)
    {
        app.togglePalettes();
        activeDocument.quickMaskMode = false;       // turn off quick mask to prevent some export problems
        log("START: Export(" + localExport + ", " + exportAll + ", " + enableP4 + ", " + hdVersion + ")", 1, 3);

        ShowWipDialog();
        //----- Prepare -----
        if (app.justExported) {
            app.justExported = false;
            return true;
        }
    
        if (hdVersion) {
            app.ls3DCustomData.enginePath 
        }
        
        var originalDocument = app.activeDocument;
        UpdateWipDialog(1, "Fixing group names", false);
        if (!exportAll) BackupLayerVisibility(originalDocument);
        FixGroupNames(originalDocument);                                        // go through group names and fix recognized but wrongly set names
        if (!exportAll) RestoreLayerVisibility(originalDocument);
        //----- Get Parent for single export -----
        var mapTypeID = -1;
        if (!exportAll) {   
            UpdateWipDialog(15, "Searching for selected group", false);
            var selectedLayerBackup = originalDocument.activeLayer;                 // backup active layer
            app.selectedLayer = originalDocument.activeLayer;
            app.selectedLayer = FindTopMostLayer(app.selectedLayer);
    
            UpdateWipDialog(5, "Testing selected group", false);
            var selectedGroupID = CheckSelectedLayer(app.selectedLayer);
            if (selectedGroupID == -1) { 
                log("END: ExportSelectedLayer( localExport = " + localExport + " ) = false", 3, 1);     
                return false; 
            }

            UpdateWipDialog(5, "Searching for correct map type", false);        
            
            var tempMapTypeIDArray = FindMapTypeIDByGroupID(selectedGroupID);     // find map type that belongs to selected group
            // When FindMapTypeIDByGroupID returns more then one result, these are checked against enaled/disabled status in configuration and disabled ones are removed.
            // This allows user to set which texture type he wants to export but use the same layer group type.

            mapTypeID = ValidateMapIDs(tempMapTypeIDArray);
            if (mapTypeID == -1)
            {
                HideWipDialog();
                log("END: Export() " + localExport + ", " + exportAll + ")", 1, 3);
                app.togglePalettes();
                app.saveAndRestartExport = true;
                return false;
            }
        }

        //----- Merge -----
        log("Merging layers.", 1, 3);
        var mergeOk = false;
        try {
            UpdateWipDialog(5, "Duplicating document", false);
            var duplicatedOriginal = DuplicateDocument(originalDocument);
            UpdateWipDialog(5, "Merging layer groups", false);
            mergeOk = MergeGroups(duplicatedOriginal);
        } catch (e) {
            log("Error in Merging layers. Please unhide at least one layer.", 3, 1);
            log("Last error: " + e.toString(), 3, 1);
            mergeOk = false;
        }
        
        if (!mergeOk) {
            duplicatedOriginal.close(SaveOptions.DONOTSAVECHANGES);
            HideWipDialog();
            log("END: Export() " + localExport + ", " + exportAll + ")", 1, 3);        
            app.togglePalettes()
            return false;            
        }
        //----- Export -----
        var result = true;
        app.C_DELETE_TEMP_FILES = !app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS;  // will not delete temp TGA file        
        if (!exportAll) {
            ExportSelectedLayer(originalDocument, duplicatedOriginal, mapTypeID, localExport, enableP4, hdVersion);
        } else {
            ExportAllLayers(originalDocument, duplicatedOriginal, localExport, enableP4, hdVersion);
        }
        //----- Cleanup -----
        duplicatedOriginal.close(SaveOptions.DONOTSAVECHANGES);
        HideWipDialog();
        log("END: Export() " + localExport + ", " + exportAll + ")", 1, 3);        
        app.togglePalettes()
    }
}
//--------- /END EXPORT FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- UI FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateConfigUI()
    {
        log ("START: CreateConfigUI()", 0);
        var borderOffset = 15; 
        var textHeight = 18;
        var buttonWidth = 100;
        var labelWidth = 95;
        var width = 600;
        var height = (2 * borderOffset) + 184;
        app.ls3dConfigWindow = new Window('dialog', "Config Paths", {x:100, y:100, width:width, height:height});
        
        app.ls3dConfigWindow.labelEnginePath = app.ls3dConfigWindow.add('statictext', {x:borderOffset, y:textHeight + 2, width:labelWidth, height:textHeight}, "Engine path:");
        app.ls3dConfigWindow.editEnginePath = app.ls3dConfigWindow.add('edittext', {x:borderOffset + labelWidth, y:textHeight, width:width - 2 * borderOffset - 120, height:textHeight}, app.ls3DCustomData.enginePath);
        app.ls3dConfigWindow.btBrowseEnginePath = app.ls3dConfigWindow.add('button', {x:width - 40, y:textHeight, width:textHeight, height:textHeight},"...");
        app.ls3dConfigWindow.labelEngineExample = app.ls3dConfigWindow.add('statictext', {x:borderOffset + labelWidth, y:2 * textHeight + 4, width:width - borderOffset - 25, height:textHeight}, "Example - d:\\!2k_games\\scotch_dev\\edit\\");
        
        app.ls3dConfigWindow.labelUtilsPath = app.ls3dConfigWindow.add('statictext', {x:borderOffset, y:4 * textHeight + 2, width:labelWidth, height:textHeight}, "Utils path:");
        app.ls3dConfigWindow.editUtilsPath = app.ls3dConfigWindow.add('edittext', {x:borderOffset + labelWidth, y:4 * textHeight, width:width - 2 * borderOffset - 120, height:textHeight}, app.ls3DCustomData.utilsPath);
        app.ls3dConfigWindow.btBrowseUtilsPath = app.ls3dConfigWindow.add('button', {x:width - 40, y:4 * textHeight, width:textHeight, height:textHeight},"...");
        app.ls3dConfigWindow.labelUtilsExample = app.ls3dConfigWindow.add('statictext', {x:borderOffset + labelWidth, y:5 * textHeight + 4, width:width - borderOffset - 25, height:textHeight}, "Example - d:\\!2k_games\\scotch_dev\\resources\\utilities\\3dsmax\\");
        
        app.ls3dConfigWindow.labelResourcesPath = app.ls3dConfigWindow.add('statictext', {x:borderOffset, y:7 * textHeight + 2, width:labelWidth, height:textHeight}, "Resources path:");
        app.ls3dConfigWindow.editResourcesPath = app.ls3dConfigWindow.add('edittext', {x:borderOffset + labelWidth, y:7 * textHeight, width:width - 2 * borderOffset - 120, height:textHeight}, app.ls3DCustomData.resourcesPath);
        app.ls3dConfigWindow.btBrowseResourcesPath = app.ls3dConfigWindow.add('button', {x:width - 40, y:7 * textHeight, width:textHeight, height:textHeight},"...");
        app.ls3dConfigWindow.labelResourceExample = app.ls3dConfigWindow.add('statictext', {x:borderOffset + labelWidth, y:8 * textHeight + 4, width:width - borderOffset - 25, height:textHeight}, "Example - d:\\!2k_games\\scotch_dev\\resources\\graphics\\");

        app.ls3dConfigWindow.btOk = app.ls3dConfigWindow.add('button', {x:borderOffset, y:(height - borderOffset - textHeight), width:buttonWidth, height:textHeight},'OK', {name:'ok'});
        app.ls3dConfigWindow.btCancel = app.ls3dConfigWindow.add('button', {x:2 * borderOffset + buttonWidth, y:(height - borderOffset - textHeight), width:buttonWidth, height:textHeight},'CANCEL', {name:'cancel'});
        app.ls3dConfigWindow.btLoadPaths = app.ls3dConfigWindow.add('button', {x:width - borderOffset - buttonWidth, y:(height - borderOffset - textHeight), width:buttonWidth, height:textHeight},'LOAD PATHS', {name:'cancel'});
        
        app.backupEnginePath = app.ls3dConfigWindow.editEnginePath.text;
        app.backupUtilsPath = app.ls3dConfigWindow.editUtilsPath.text;
        app.backupResourcesPath = app.ls3dConfigWindow.editResourcesPath.text;
//        app.ls3dConfigWindow.editEnginePath.enabled = false;
//        app.ls3dConfigWindow.editUtilsPath.enabled = false;
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.btOk.onClick = function ()
        {
            app.ls3DCustomData.enginePath = app.ls3dConfigWindow.editEnginePath.text;
            app.ls3DCustomData.utilsPath = app.ls3dConfigWindow.editUtilsPath.text;
            app.ls3DCustomData.resourcesPath = app.ls3dConfigWindow.editResourcesPath.text;
            SaveSystemPathsToEnvVariables();
            app.ls3dConfigWindow.hide();
        }        
    
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.btBrowseEnginePath.onClick = function () 
        {
            var sourceFolder = app.ls3DCustomData.enginePath;
            var tempFolder = (Folder(sourceFolder).selectDlg("Select engine directory..."));
            if (tempFolder!= null) {
                app.ls3dConfigWindow.editEnginePath.text = GetPathInWinNotation(tempFolder.toString());
                app.backupEnginePath = app.ls3dConfigWindow.editEnginePath.text;
            }
        }
    
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.btBrowseUtilsPath.onClick = function () 
        {
            var sourceFolder = app.ls3DCustomData.utilsPath;
            var tempFolder = (Folder(sourceFolder).selectDlg("Select engine directory..."));
            if (tempFolder!= null) {
                app.ls3dConfigWindow.editUtilsPath.text = GetPathInWinNotation(tempFolder.toString());
                app.backupUtilsPath = app.ls3dConfigWindow.editUtilsPath.text;
            }
        }        
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.btBrowseResourcesPath.onClick = function () 
        {
            var sourceFolder = app.ls3DCustomData.resourcesPath;
            var tempFolder = (Folder(sourceFolder).selectDlg("Select resources directory..."));
            if (tempFolder!= null) {
                app.ls3dConfigWindow.editResourcesPath.text = GetPathInWinNotation(tempFolder.toString());
                app.backupResourcesPath = app.ls3dConfigWindow.editResourcesPath.text;
            }
        } 
    
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.btLoadPaths.onClick = function () 
        {
            app.ls3DCustomData.utilsPath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_UTILS, true);
            app.ls3DCustomData.enginePath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_ENGINE, true);
            app.ls3DCustomData.resourcesPath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_RESOURCES, true);
            app.ls3DCustomData.editorPath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_EDITOR, true);

            app.ls3dConfigWindow.editEnginePath.text = app.ls3DCustomData.enginePath;
            app.ls3dConfigWindow.editUtilsPath.text = app.ls3DCustomData.utilsPath;
            app.ls3dConfigWindow.editResourcesPath.text = app.ls3DCustomData.resourcesPath;
            /*TODO: add configuration of Editor Path */
        }
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.editEnginePath.onChange = function () 
        {
            folder = new Folder(app.ls3dConfigWindow.editEnginePath.text);
            if (!folder.exists) app.ls3dConfigWindow.editEnginePath.text = app.backupEnginePath
            else app.backupEnginePath = app.ls3dConfigWindow.editEnginePath.text;
        }
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.editUtilsPath.onChange = function () 
        {
            folder = new Folder(app.ls3dConfigWindow.editUtilsPath.text);
            if (!folder.exists) app.ls3dConfigWindow.editUtilsPath.text = app.backupUtilsPath
            else app.backupUtilsPath = app.ls3dConfigWindow.editUtilsPath.text;
        }
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dConfigWindow.editResourcesPath.onChange = function () 
        {
            folder = new Folder(app.ls3dConfigWindow.editResourcesPath.text);
            if (!folder.exists) app.ls3dConfigWindow.editResourcesPath.text = app.backupResourcesPath
            else app.backupResourcesPath = app.ls3dConfigWindow.editResourcesPath.text;
        }      
        log ("END: CreateConfigUI()", 0);
        return true;
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ShowConfigUI()
    {
        log ("ShowConfigUI()", 0); 
        if (CreateConfigUI()) {
            app.ls3dConfigWindow.center();
            app.ls3dConfigWindow.show();
            return true;
        } else return false;        
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateGenLayersUI()
    {
        log ("START: CreateGenLayersUI()", 0);
        var groupList = app.ls3dUserGroupTypes.userGroupList;
        var groupListLength = groupList.length;
        if (groupListLength <= 0) {
            log("Configuration with User Group Types was not succesfully loaded. Generation is disabled.", 3, 1);
            log ("END: CreateGenLayersUI() = false", 3, 1);
            return false;
        }
        var borderOffset = 15; 
        var textHeight = 18;
        var buttonWidth = 100;
        var width = 250;
        var height = (2 * borderOffset) + (groupListLength * textHeight) + 25;
        app.ls3dGenLayersWindow = new Window('dialog', "Generate Layers UI v" + C_SCRIPT_VERSION, {x:100, y:100, width:width, height:height});

        var count = 0;
        app.ls3dGenLayersWindow.list = new Array();
        for (count = 0; count < groupListLength; count++) {
            var tempRadioButton = app.ls3dGenLayersWindow.add('radioButton', {x:borderOffset, y:(borderOffset + count * textHeight), width:width - (2 * borderOffset), height:textHeight}, (groupList[count].name), {alignment: 'left'});
            app.ls3dGenLayersWindow.list.push(tempRadioButton);
        }
        app.ls3dGenLayersWindow.list[0].value = true;
        app.ls3dGenLayersWindow.btOk = app.ls3dGenLayersWindow.add('button', {x:borderOffset, y:(borderOffset + count * textHeight + 10), width:buttonWidth, height:textHeight},'GENERATE', {name:'ok'});
        app.ls3dGenLayersWindow.btCancel = app.ls3dGenLayersWindow.add('button', {x:2*borderOffset + buttonWidth, y:(borderOffset + count * textHeight + 10), width:buttonWidth, height:textHeight},'CANCEL', {name:'cancel'});
        
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dGenLayersWindow.btOk.onClick = function ()
        {
            var list = app.ls3dGenLayersWindow.list;
            for (var i = 0; i < list.length; i++) {
                if (list[i].value) { GenerateLayers(app.activeDocument, list[i].text); }
            }
            app.ls3dGenLayersWindow.hide();
        }        
        log ("END: CreateGenLayersUI() = true", 0);
        return true;        
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ShowGenLayersUI()
    {
        log ("ShowGenLayersUI()", 0); 
        if (CreateGenLayersUI()) {
            app.ls3dGenLayersWindow.center();
            app.ls3dGenLayersWindow.show();
            return true;
        } else return false;
    }


    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function GetPanelIndexByName(name)
    {
        var result = -1;
        for (var i = 0; i < app.ls3DCustomData.formats.length; i++) {
            if ((name) == app.ls3DCustomData.formats[i].name) result = i;
        }
        return result;
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateFormatPanelUI(panelFormats, panelIndex, format, formatIndex, panelName, borderOffset, pFormatHeight, width, textHeight)
    {
        var index = panelIndex;
        var mainPanel = panelFormats.formats[index];

        var currentPanel = panelFormats.formats[index];
        var items;
        
        currentPanel.labelFormat = currentPanel.add('statictext', {x:borderOffset, y:borderOffset + 2, width:80, height:textHeight}, "DDS Format:");            
        currentPanel.listFormat = currentPanel.add('dropdownlist', {x:borderOffset + 80, y:borderOffset, width:85, height:textHeight}, items);
        for (var i = 0; i < app.ls3dDdsExportData.mapTypes[formatIndex].formats.length; i++) currentPanel.listFormat.add("item", C_DXT_FORMATS[app.ls3dDdsExportData.mapTypes[formatIndex].formats[i]]);
       
        currentPanel.labelScale = currentPanel.add('statictext', {x:borderOffset, y:borderOffset + (textHeight + 7), width:80, height:textHeight}, "Scale image:");
        currentPanel.editScale = currentPanel.add('dropdownlist', {x:borderOffset + 80, y:borderOffset + (textHeight + 5), width:85, height:textHeight}, items);
        for (var i = 0; i < C_SCALES.length; i++) currentPanel.editScale.add("item", C_SCALES[i]);
        
        currentPanel.checkCubemap = currentPanel.add('checkbox', {x:borderOffset + 180, y:borderOffset, width:80, height:textHeight}, "Cubemap"); //.value = [bool]
        currentPanel.custMipMap = currentPanel.add('checkbox', {x:borderOffset + 180, y:borderOffset + (textHeight + 5), width:120, height:textHeight}, "Custom mipmap"); //.value = [bool]
        
//            currentPanel.labelQuality = currentPanel.add('statictext', {x:borderOffset + 305, y:borderOffset + 2, width:40, height:textHeight}, "Quality:");
//            currentPanel.editQuality = currentPanel.add('dropdownlist', {x:borderOffset + 350, y:borderOffset, width:140, height:textHeight}, items);
//            for (var i = 0; i < C_QUALITY.length; i++) currentPanel.editQuality.add("item", C_QUALITY[i]);

        currentPanel.infoButton = currentPanel.add('button', {x:borderOffset + 300, y:borderOffset, width:185, height:textHeight},'Layer Groups INFO');

        currentPanel.labelMipmaps = currentPanel.add('statictext', {x:borderOffset + 300, y:borderOffset + (textHeight + 7), width:110, height:textHeight}, "Maximum mipmaps:");
        currentPanel.editMipmaps = currentPanel.add('dropdownlist', {x:borderOffset + 410, y:borderOffset + (textHeight + 5), width:75, height:textHeight}, items);
        // adding only 0 and all mipmaps
        for (var i = 0; i < C_MIPMAPS.length; i++) currentPanel.editMipmaps.add("item", C_MIPMAPS[i]);

        currentPanel.labelSharpening = currentPanel.add('statictext', {x:borderOffset + 300, y:borderOffset + 2 * (textHeight + 5) + 2, width:65, height:textHeight}, "Resize Filter:");
        currentPanel.editSharpening = currentPanel.add('dropdownlist', {x:borderOffset + 370, y:borderOffset + 2 * (textHeight + 5), width:115, height:textHeight}, items);
        for (var i = 0; i < C_RESIZE_FILTER.length; i++) currentPanel.editSharpening.add("item", C_RESIZE_FILTER[i]);

        currentPanel.labelResolution = currentPanel.add('statictext', {x:borderOffset, y:borderOffset + 2 * (textHeight + 5), width:80, height:textHeight}, "Resolution:");
        currentPanel.editResolutionX = currentPanel.add('dropdownlist', {x:borderOffset + 75, y:borderOffset + 2 * (textHeight + 5), width:85, height:textHeight}, items);
        currentPanel.editResolutionY = currentPanel.add('dropdownlist', {x:borderOffset + 165, y:borderOffset + 2 * (textHeight + 5), width:85, height:textHeight}, items);
        for (var i = 0; i < C_RESOLUTIONS.length; i++) {
            currentPanel.editResolutionX.add("item", C_RESOLUTIONS[i]);
            currentPanel.editResolutionY.add("item", C_RESOLUTIONS[i]);
        }

        currentPanel.checkScaleFilter = currentPanel.add('statictext', {x:borderOffset, y:borderOffset + 2 * (textHeight + 5) + 2, width:80, height:textHeight}, "Scale filter:");
        currentPanel.editScaleFilter = currentPanel.add('dropdownlist', {x:borderOffset + 80, y:borderOffset + 2 * (textHeight + 5), width:85, height:textHeight}, items);
        currentPanel.checkScaleFilter.visible = false;
        currentPanel.editScaleFilter.visible = false;
        for (var i = 0; i < C_SCALE_FILTER.length; i++) currentPanel.editScaleFilter.add("item", C_SCALE_FILTER[i]);


        // ------------ Setting values from cutom data ----------------------//

        
        if (app.ls3dDdsExportData.mapTypes[formatIndex].formats.length > format.ddsFormat) {
            currentPanel.listFormat.selection = format.ddsFormat;
        } else {
            currentPanel.listFormat.selection = C_F_DEFAULT_DDSFORMAT;
            app.ls3DCustomData.formats[formatIndex].ddsFormat = C_F_DEFAULT_DDSFORMAT;
        }
        
        currentPanel.editResolutionX.selection = format.resolutionX;
        currentPanel.editResolutionY.selection = format.resolutionY;
        currentPanel.editScale.selection = format.scale;
        currentPanel.editScaleFilter.selection = format.scaleFilter;
        currentPanel.checkCubemap.value = Boolean(format.cubemap);
//            currentPanel.editQuality.selection = format.quality;
        currentPanel.editMipmaps.selection = format.mipmaps;
        currentPanel.editSharpening.selection = format.filter;
        currentPanel.custMipMap.value = Boolean(format.customMipmaps);
        if (currentPanel.checkCubemap.value) {
            currentPanel.custMipMap.enabled = false;
            currentPanel.custMipMap.value = false;
        } else currentPanel.custMipMap.enabled = true;
    
        if (currentPanel.custMipMap.value) {
            currentPanel.labelMipmaps.enabled = false;
            currentPanel.editMipmaps.enabled = false;
            currentPanel.checkCubemap.enabled = false;
        } else {
            currentPanel.labelMipmaps.enabled = true;
            currentPanel.editMipmaps.enabled = true;
            currentPanel.checkCubemap.enabled = true;
        }            

        currentPanel.labelSharpening.enabled = true;
        currentPanel.editSharpening.enabled = true;

       
        app.ls3dMainWindow.pnlSave.checkDebug.value = app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS;
        app.ls3dMainWindow.pnlSave.checkFlipNormal.value = app.C_DEBUG_FLIP_NORMAL;


        // ----- Add Events ----- //
        app.ls3dMainWindow.pnlSave.checkDebug.onClick = function(){ app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS = this.value; };
        app.ls3dMainWindow.pnlSave.checkFlipNormal.onClick = function(){ app.C_DEBUG_FLIP_NORMAL = this.value; };
        currentPanel.listFormat.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).ddsFormat = this.selection.index; };
        currentPanel.editScale.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).scale = this.selection.index; };
        currentPanel.editResolutionX.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).resolutionX = this.selection.index; };
        currentPanel.editResolutionY.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).resolutionY = this.selection.index; };
  
        currentPanel.checkCubemap.onClick = function(){ 
            (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).cubemap = this.value; 
            if (this.value) {
                this.parent.custMipMap.enabled = false;
                this.parent.custMipMap.value = false;
            } else this.parent.custMipMap.enabled = true;
        };
//            currentPanel.editQuality.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).quality = this.selection.index; };
        currentPanel.infoButton.onClick = function(){ 
            var temp = GetPanelIndexByName(this.parent.text);
            var mapTypeID = FindMapTypeIDByGroupID(temp);
            var groups = FindGroupsByMapTypeID(temp);
            var infoString = "";
            var foundGroups = new Array;
            for (var i = 0; i < groups.length; i++) {
                var group = groups[i];
                var groupID = FindGroupTypeIDByType(group);
                var found = false;
                if (groupID != -1) {
                    for (var j = 0; j < foundGroups.length; j++) {
                        if (foundGroups[j] == groupID) { found = true };
                    }
                    if (!found) {
                        foundGroups.push(groupID);
                        var groupType = app.ls3dDdsExportData.groupTypes[groupID];
                        infoString += groupType.description + "\n";
                    }
                }
            }
            log("infoString: " + infoString, 0);
            alert(infoString, "Layer Groups Info", false);
        };
        currentPanel.editMipmaps.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).mipmaps = this.selection.index; };
        currentPanel.editScaleFilter.onChange = function(){ (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).scaleFilter = this.selection.index; };
        currentPanel.editSharpening.onChange = function(){
            var temp = this.selection.index;
            var temp2 = (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).filter;
            (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).filter = this.selection.index;
        };
        currentPanel.custMipMap.onClick = function(){ 
            (app.ls3DCustomData.formats[GetPanelIndexByName(this.parent.text)]).customMipmaps = this.value; 
            if (this.value) {
                this.parent.labelMipmaps.enabled = false;
                this.parent.editMipmaps.enabled = false;
                this.parent.checkCubemap.enabled = false;
            } else {
                this.parent.labelMipmaps.enabled = true;
                this.parent.editMipmaps.enabled = true;
                this.parent.checkCubemap.enabled = true;
            }
        };        
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CleanFormatPanelsUI()
    {
        if (app.ls3dMainWindow.pnlFormats != null) {
            app.ls3dMainWindow.remove(app.ls3dMainWindow.pnlFormats);
            app.ls3dMainWindow.pnlFormats = null;
        }
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function RefreshFormatPannelsUI(selectedMapNamesIndex, borderOffset, pFormatHeight, width, textHeight)
    {
        var mapNames = app.ls3dUserMapTypes.userMapList[selectedMapNamesIndex].mapNames;
        if (app.ls3dMainWindow.pnlFormats == null) {
            var p1height = 115;
            var p2height = 945;
            var pFormatHeight = 100;
            borderOffset = 15;
            app.ls3dMainWindow.pnlFormats = app.ls3dMainWindow.add('panel', {x:borderOffset, y:borderOffset + p1height, width:width - 2 * borderOffset, height:p2height}, "FORMATS SETTINGS");
            app.ls3dMainWindow.pnlFormats.formats = new Array();
            var C_MIN_COUNT = Math.floor(p2height / (pFormatHeight + 5));     // minimalni pocet panelu ktery se mi vejdou do okna bez scrolovani
            var panelsHeight = 0;
            var panelsCount = mapNames.length;
            if (panelsCount > C_MIN_COUNT) panelsHeight = (panelsCount - C_MIN_COUNT) * (pFormatHeight); // nastaveni rychlosti scrollu pokud mam vic panelu nez se vejde do okna
            app.ls3dMainWindow.pnlFormats.widthScrl = app.ls3dMainWindow.pnlFormats.add('scrollbar',{x:width - 2 * borderOffset - textHeight - 7, y:0, width:textHeight + 1, height:p2height -10}, 0, 0, panelsHeight);
            log(" panelsCount = " + panelsCount.toString(), 1, 3);
        }
        app.ls3dMainWindow.pnlFormats.hide();
        borderOffset = 15;
        var mapNames = app.ls3dUserMapTypes.userMapList[selectedMapNamesIndex].mapNames;
        var createdPanels = 0;
        for (var index = 0; index < app.ls3dDdsExportData.mapTypes.length; index++) {
            var panelName = app.ls3dDdsExportData.mapTypes[index].name;

            var formatIndex = GetPanelIndexByName(panelName);
            if (formatIndex == -1) {        // testing existency of format
                 //.. if not found, create new and use default values
                app.ls3DCustomData.formats.push(GetDefaultFormat(panelName));
                formatIndex = app.ls3DCustomData.formats.length - 1;
            }

            var mapFound = false;
            for (var i = 0; i < mapNames.length; i++) {
                if (mapNames[i] == panelName) { mapFound = true; }
            }
            if (mapFound) {
                var format = app.ls3DCustomData.formats[formatIndex];
                log("Creating panel. Name = " + panelName.toString() + ", disabled = " + format.disabled.toString(), 1, 3);
                app.ls3dMainWindow.pnlFormats.formats.push(app.ls3dMainWindow.pnlFormats.add('panel', {x:borderOffset, y:borderOffset + index * pFormatHeight, width:width - 5 * borderOffset, height:pFormatHeight}, (panelName)));
                CreateFormatPanelUI(app.ls3dMainWindow.pnlFormats, createdPanels, format, formatIndex, panelName, borderOffset, pFormatHeight, width, textHeight);
                createdPanels += 1;
            }
        }
        app.ls3dMainWindow.pnlFormats.show();
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlFormats.widthScrl.onChange = function ()
        {
            app.ls3dMainWindow.pnlFormats.hide();
            var offset = -Math.round(this.parent.widthScrl.value);
            for (var index = 0; index < app.ls3dMainWindow.pnlFormats.formats.length; index++)
            {
                app.ls3dMainWindow.pnlFormats.formats[index].bounds.y = borderOffset + index * pFormatHeight + offset;
                app.ls3dMainWindow.pnlFormats.formats[index].bounds.bottom =  pFormatHeight + borderOffset + index * pFormatHeight + offset;
            }
            app.ls3dMainWindow.pnlFormats.show();
        } 
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlFormats.widthScrl.onChanging = function ()
        {
            app.ls3dMainWindow.pnlFormats.hide();
            var offset = -Math.round(this.parent.widthScrl.value);
            for (var index = 0; index < app.ls3dMainWindow.pnlFormats.formats.length; index++)
            {
                app.ls3dMainWindow.pnlFormats.formats[index].bounds.y = borderOffset + index * pFormatHeight + offset;
                app.ls3dMainWindow.pnlFormats.formats[index].bounds.bottom =  pFormatHeight + borderOffset + index * pFormatHeight + offset;
            }
            app.ls3dMainWindow.pnlFormats.show();
        }       
    }
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateUI()
    {
        log ("START: CreateUI()", 0);
        var width = 600;
        var height = 1155;
        var borderOffset = 15;    
        var p1height = 110;
        var p2height = 960;
        var p3height = 60;
        var pFormatHeight = 100;
        var textHeight = 18;
        var buttonWidth = 100;
        app.ls3dMainWindow = new Window('dialog', "DDS Export - v" + C_SCRIPT_VERSION, {x:100, y:100, width:width, height:height});
        //-------------- panels ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlPaths = app.ls3dMainWindow.add('panel', {x:borderOffset, y:borderOffset, width:width - 2 * borderOffset, height:p1height}, "GLOBAL PATHS SETTINGS");
        app.ls3dMainWindow.pnlSave = app.ls3dMainWindow.add('panel', {x:borderOffset, y:borderOffset + p1height + p2height, width:width - 2*borderOffset, height:p3height}, '');
        //-------------- /end panels ----------------------------------------------------------------------------------------------------------------------------------------------------
      
        //-------------- panel paths ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//        app.ls3dMainWindow.pnlPaths.labelExporter = app.ls3dMainWindow.pnlPaths.add('statictext', {x:borderOffset, y:17, width:130, height:textHeight}, "NVIDIA Exporter path:");
//        app.ls3dMainWindow.pnlPaths.editExporter = app.ls3dMainWindow.pnlPaths.add('edittext', {x:borderOffset + 130, y:15, width:390 , height:textHeight}, app.C_NVIDIA_TOOLS_PATH);

        app.ls3dMainWindow.pnlPaths.labelEnginePath = app.ls3dMainWindow.pnlPaths.add('statictext', {x:borderOffset, y:17, width:130, height:textHeight}, "Engine path:");
        app.ls3dMainWindow.pnlPaths.editEnginePath = app.ls3dMainWindow.pnlPaths.add('edittext', {x:borderOffset + 130, y:15, width:390 , height:textHeight}, app.ls3DCustomData.enginePath);
        
        app.ls3dMainWindow.pnlPaths.checkExportPath = app.ls3dMainWindow.pnlPaths.add('checkbox', {x:borderOffset, y:40, width:130, height:textHeight}, "");
        app.ls3dMainWindow.pnlPaths.labelExportPath = app.ls3dMainWindow.pnlPaths.add('statictext', {x:borderOffset + 25, y:42, width:130, height:textHeight}, "Export path:");
        app.ls3dMainWindow.pnlPaths.editExportPath = app.ls3dMainWindow.pnlPaths.add('edittext', {x:borderOffset + 130, y:40, width:390 , height:textHeight}, app.ls3DCustomData.exportPath);        
        app.ls3dMainWindow.pnlPaths.btBrowsePath = app.ls3dMainWindow.pnlPaths.add('button', {x:borderOffset + 525, y:40, width:textHeight, height:textHeight},"...");

        app.ls3dMainWindow.pnlPaths.editEnginePath.enabled = false;
        var savedVersion = StringToNumber(app.ls3DCustomData.version);
        if (savedVersion == 0) {
            app.ls3dMainWindow.pnlPaths.editExportPath.enabled = false;
            app.ls3dMainWindow.pnlPaths.btBrowsePath.enabled = false;
        } else {
            app.ls3dMainWindow.pnlPaths.checkExportPath.value = app.ls3DCustomData.customExportPath;
            app.ls3dMainWindow.pnlPaths.editExportPath.enabled = app.ls3DCustomData.customExportPath;
            app.ls3dMainWindow.pnlPaths.btBrowsePath.enabled = app.ls3DCustomData.customExportPath;
            if (!app.ls3DCustomData.customExportPath) {
                app.ls3dMainWindow.pnlPaths.editExportPath.text = GetAutomaticExportPath();
            }            
        }
        app.ls3dMainWindow.pnlPaths.labelProfileType = app.ls3dMainWindow.pnlPaths.add('statictext', {x:borderOffset, y:67, width:50, height:textHeight}, "Profile:");
        var profileItems;
        app.ls3dMainWindow.pnlPaths.listProfiles = app.ls3dMainWindow.pnlPaths.add('dropdownlist', {x:borderOffset + 50, y:65, width:200, height:textHeight}, profileItems);
        for (var i = 0; i < app.ls3dUserMapTypes.userMapList.length; i++) app.ls3dMainWindow.pnlPaths.listProfiles.add("item", app.ls3dUserMapTypes.userMapList[i].name);
        var profileIndex = GetProfileIndexByName(app.ls3DCustomData.profile);
        if (profileIndex != -1) app.ls3dMainWindow.pnlPaths.listProfiles.selection = profileIndex;
        
//~         var labelInfoWidth = 300;
//~         app.ls3dMainWindow.labelInfo = app.ls3dMainWindow.add('statictext', {x:((width - labelInfoWidth) / 2), y:height * 0.33 - textHeight, width:labelInfoWidth, height:textHeight}, "Creating UI elements. This may take a few seconds...");
        //---------------- /end panel paths ----------------------------------------------------------------------------------------------------------------------------------------------


        //-------------- panel save ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlSave.btOk = app.ls3dMainWindow.pnlSave.add('button', {x:borderOffset, y:borderOffset, width:buttonWidth, height:textHeight},'SAVE CHANGES', {name:'ok'});
        app.ls3dMainWindow.pnlSave.btCancel = app.ls3dMainWindow.pnlSave.add('button', {x:2 * borderOffset + buttonWidth, y:borderOffset, width:buttonWidth, height:textHeight},'CANCEL', {name:'cancel'});
        app.ls3dMainWindow.pnlSave.btOkExport = app.ls3dMainWindow.pnlSave.add('button', {x:3 * borderOffset + 2 * buttonWidth, y:borderOffset, width:buttonWidth + 30, height:textHeight},'SAVE and EXPORT', {name:'ok'});
        app.ls3dMainWindow.pnlSave.btChangePaths = app.ls3dMainWindow.pnlSave.add('button', {x:4 * borderOffset + 3 * buttonWidth + 30, y:borderOffset, width:buttonWidth - 30, height:textHeight},'Paths', {name:'ok'});
        app.ls3dMainWindow.pnlSave.checkDebug = app.ls3dMainWindow.pnlSave.add('checkbox', {x:borderOffset + 450, y:borderOffset - 6, width:120, height:textHeight}, "Debug mode"); //.value = [bool]
        app.ls3dMainWindow.pnlSave.checkFlipNormal = app.ls3dMainWindow.pnlSave.add('checkbox', {x:borderOffset + 450, y:borderOffset + 15, width:120, height:textHeight}, "Normal Flip Y"); //.value = [bool]
        //-------------- /end panel save -------------------------------------------------------------------------------------------------------------------------------------------------


        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlPaths.checkExportPath.onClick = function(){ 
            app.ls3dMainWindow.pnlPaths.editExportPath.enabled = this.value;
            app.ls3dMainWindow.pnlPaths.btBrowsePath.enabled = this.value;
            app.ls3DCustomData.customExportPath = this.value;
            if (!this.value) {
                app.ls3dMainWindow.pnlPaths.editExportPath.text = GetAutomaticExportPath();
            } else {
                app.ls3dMainWindow.pnlPaths.editExportPath.text = app.ls3DCustomData.exportPath;
            }
        }
        
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlPaths.listProfiles.onChange = function()
        {
            if ((this.selection.index != null) && (this.selection.index < app.ls3dUserMapTypes.userMapList.length)) {
                var borderOffset = 7;
                var pFormatHeight = 100;
                var width = 600;
                var textHeight = 18;
               
                CleanFormatPanelsUI();
                var profileIndex = this.selection.index;
                RefreshFormatPannelsUI(profileIndex, borderOffset, pFormatHeight, width, textHeight);
                app.ls3dMainWindow.pnlFormats.widthScrl.notify("onChange");         // just to refresh formats panel
                
                var mapNames = app.ls3dUserMapTypes.userMapList[this.selection.index].mapNames;
                for (var i = 0; i < app.ls3DCustomData.formats.length; i++) {
                    (app.ls3DCustomData.formats[i]).disabled = 1;
                }
                for (var i = 0; i < mapNames.length; i++) {
                    var formatIndex = GetPanelIndexByName(mapNames[i]);
                    if (formatIndex > -1) {
                        (app.ls3DCustomData.formats[formatIndex]).disabled = 0;                    
                    } else {
                        log ("Unknown Map Type in userMapTypes. Please contact some TechArtist when you see this error. MapName = " + mapNames[i], 3, 1);
                    }
                }                
            }
        };
        
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlSave.btOk.onClick = function ()
        {
            app.saveUIChanges = true;
            
            var tempPath = ValidateExportPath(this.parent.parent.pnlPaths.editExportPath.text, true);
            if (tempPath != "") {
                app.ls3DCustomData.exportPath = tempPath;
                if (app.ls3DCustomData.exportPath == "") app.ls3DCustomData.exportPath = app.C_BASE_EXPORT_PATH;
                app.ls3DCustomData.profile = app.ls3dMainWindow.pnlPaths.listProfiles.selection;
                app.ls3dMainWindow.hide();
            } else {
                log("Selected folder is outside engine directory. Or does not exist. That's not allowed.", 3, 1);
            }
        }
        
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlSave.btOkExport.onClick = function ()
        {
            var tempPath = ValidateExportPath(this.parent.parent.pnlPaths.editExportPath.text, true);
            if (tempPath != "") {            
                app.ls3DCustomData.exportPath = this.parent.parent.pnlPaths.editExportPath.text;
                if (app.ls3DCustomData.exportPath == "") app.ls3DCustomData.exportPath = app.C_BASE_EXPORT_PATH;
                app.ls3DCustomData.profile = app.ls3dMainWindow.pnlPaths.listProfiles.selection;
                app.ls3dMainWindow.hide();
                SaveCustomAttribs();  
                Export(false, false, true, false);
                app.justExported = true;
            } else {
                log("Selected folder is outside engine directory. Or does not exist. That's not allowed.", 3, 1);
            }                
        }   
    
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlSave.btChangePaths.onClick = function () 
        {
            ShowConfigUI();            
            app.ls3dMainWindow.pnlPaths.editEnginePath.text = app.ls3DCustomData.enginePath;
        }      
    
        //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
        app.ls3dMainWindow.pnlPaths.btBrowsePath.onClick = function () 
        {
            var sourceFolder = app.ls3DCustomData.enginePath + app.ls3DCustomData.exportPath;
            var tempFolder = (Folder(sourceFolder).selectDlg("Select export directory...")).toString();
            tempFolder = ValidateExportPath(tempFolder, false);
            if (tempFolder != "") {
                this.parent.editExportPath.text = tempFolder;
                app.ls3DCustomData.exportPath = tempFolder;
            } else {
                log("Selected folder is outside engine directory. That's not allowed.", 3, 1);
            }
        }
/**/    
        app.ls3dMainWindow.pnlPaths.listProfiles.notify("onChange");
        log ("END: CreateUI()", 0);
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ShowGUI(reallyShowIt)
    {
        log ("ShowGUI(" + reallyShowIt.toString() + ")", 0); 
        CreateUI();
        app.ls3dMainWindow.center();
        if (reallyShowIt) {
            app.ls3dMainWindow.show();
            if (app.saveUIChanges) {
                SaveCustomAttribs();
                app.saveUIChanges = false;
            }
        } else {
            SaveCustomAttribs();
        }
        if (app.ls3DCustomData.exportPath != app.C_BASE_EXPORT_PATH) app.firstTimeSetDone = true;
        log ("END: ShowGUI(" + reallyShowIt.toString() + ")", 0); 
        return true;
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ResetWipDialog()
    {
        if (app.ls3dWipDialog != null) {
            app.ls3dWipDialog.Reset();
        }  
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function CreateWIPDialog()
    {
        if (app.ls3dWipDialog == null) {
            app.ls3dWipDialog = new WipDialog();
            app.ls3dWipDialog.Create("Export DDS", app.C_LOG_SILENT);
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function ShowWipDialog()
    {
        if (app.ls3dWipDialog == null) {
            CreateWIPDialog();
        }
        if (app.ls3dWipDialog != null) {
            app.ls3dWipDialog.Show();
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function HideWipDialog()
    {
        if (app.ls3dWipDialog != null) {
            app.ls3dWipDialog.Hide();
        }
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function UpdateWipDialog(progress, text, set)
    {
        if (app.ls3dWipDialog != null) {
            app.ls3dWipDialog.Update(progress, text, set);
        }
    }

}
//--------- /END UI FUNCTIONS --------------------------------------------------------------------------------------------------------------------------------------------------------


//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
//--------- INIT --------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
{
    function Done()
    {
        log(".......................... Script END ..........................", 1, 2);
        logClose();
        CloseExternal();
    }
    
    function PreInitFailed(appTypeString, logIntoFile)
    {
        logInit(true, "", logIntoFile, "");
        InitExternal("", false);
        logClear("\n\n", true);    
        var message = "Photoshop Tools, version: " + C_SCRIPT_VERSION + "\n" + "Script run in: " + getDateTimeStr();
        log(".......................... " + appTypeString + "...........................", 1, 2);
        log("........................ Script START ........................", 1, 2);
        log("No arguments found.", 3, 1);        
    }

    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function PreInit(arg, appTypeString, silent, logIntoFile)
    {
        var tracePath = "";
        var traceTabName = "Photoshop Tools";
        var dllPath = "";
        if (arg != null) traceTabName = arg[0];
        if (arg != null) dllPath = arg[7];
        InitExternal(dllPath, false);
            
        logInit(silent, "", logIntoFile, traceTabName);
        var message = "Photoshop Tools, version: " + C_SCRIPT_VERSION + "\n" + "Script run in: " + getDateTimeStr() + "\n" + "User machine: " + $.getenv("COMPUTERNAME");
        if (arg == null) {
            if (C_CLEAR_LOG) logClear("\n\n", true);
            else log (message, 1, 2);
        } else log(message, 1, 3);
        log(".......................... " + appTypeString + "...........................", 1, 2);
        log("........................ Script START ........................", 1, 2);
  
        if (arg != null) {
            log("Arguments.length = " + arg.length.toString(), 1, 3);
            for (i = 0; i < arg.length - 1; i++) { 
                log("argument[" + i + "] = " + arg[i].toString(), 1, 3); 
            }
        }
    }
    
    //---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
    function Init(showGUI, builderExport, utilsPath, configPath, enginePath, renamer, resourcesPath)
    {
        CleanLog();
        log("START: Init(" + showGUI + ", " + builderExport + ")", 1, 3);
        app.initDoneSuccesfully = true;
        app.justExported = false;
        app.saveUIChanges = false;
        
        app.ls3dCompressorParams = null;
        
        app.CACHE_CollapsedArtLayerNames = null;        
        app.CACHE_GroupLayerNames = null;        
        
        app.C_NVIDIA_TOOLS_PATH = "";
        app.C_NVIDIA_TOOLS_2_PATH = "";
        app.C_NVIDIA_TOOLS_2_SCALE_PATH = "";
        app.C_NVIDIA_TOOLS_2_ASSEMBLE_PATH = "";
        app.C_NVIDIA_STITCH_PATH = "";
        app.C_TEXCONV_PATH = "";
        app.C_TEXASSEMBLE_PATH = "";
        app.C_PERFORCE_ENABLED = "true";
        app.C_FILE_EXTENSION_SOURCE = "";
        app.C_FILE_EXTENSION_EXPORT = "";
        app.C_SUFFIX_SEPARATOR = "";
        app.C_CHANNEL_NAME_RED= "";
        app.C_CHANNEL_NAME_GREEN= "";
        app.C_CHANNEL_NAME_BLUE= "";
        app.C_CHANNEL_NAME_ALPHA = "";
        app.C_BASE_EXPORT_PATH = "";
        
        app.C_SELECTED_COMPRESSOR_INDEX = 2;
        
        app.C_DEBUG_PAUSE_IN_EXTERNAL_COMMANDS = false;     // all external command widows stays open
        app.C_DEBUG_FLIP_NORMAL = false;                    // flip green channel in normal map
        
        LoadDebugMode();
        app.preferences.rulerUnits = Units.PIXELS;          // Application units set to Pixels
        try {
            app.ls3dDdsExportData = new LS3DDdsExportData();
            app.ls3DCustomData = new LS3DCustomData();
            app.ls3dUserGroupTypes = new LS3DUserGroupTypes();
            app.ls3dUserMapTypes = new LS3DUserMapTypes();
            app.layerGroupsVisibilityBackup = new Array();
            
            var configXMLPath = "";

            
            if (builderExport) {
                app.ls3DCustomData.utilsPath = utilsPath;
                app.ls3DCustomData.enginePath = enginePath;
                app.ls3DCustomData.resourcesPath = resourcesPath;
                configXMLPath = app.ls3DCustomData.utilsPath + configPath;
            } else {
                if (!LoadSystemPathsFromEnvVariables()) {
                    app.ls3DCustomData.utilsPath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_UTILS, true);
                    app.ls3DCustomData.enginePath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_ENGINE, true);
                    app.ls3DCustomData.resourcesPath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_RESOURCES, true);
                    app.ls3DCustomData.editorPath = ReadEnginePath(C_REG_QUERY + C_ENVVAR_EDITOR, true);
                    if ((app.ls3DCustomData.utilsPath == "") || (app.ls3DCustomData.enginePath == "") || (app.ls3DCustomData.resourcesPath == "") || (app.ls3DCustomData.editorPath == "")) {
                        ShowConfigUI();
                    } else SaveSystemPathsToEnvVariables()
                }
                configXMLPath = app.ls3DCustomData.utilsPath + C_CONFIG_FILE;
            }
            if (!renamer) {
                if (!LoadConfigXML(configXMLPath)) { app.initDoneSuccesfully = false; return false; }
            }
            app.ls3DCustomData.exportPath = app.C_BASE_EXPORT_PATH;
            log("Engine path: " + app.ls3DCustomData.enginePath, 1, 3);
            log("Resources path: " + app.ls3DCustomData.resourcesPath, 1, 3);
            log("Export path: " + app.ls3DCustomData.exportPath, 1, 3);
            log("Utils path: " + app.ls3DCustomData.utilsPath, 1, 3);
            
            if (!renamer) {
                if (!ExportersInstalationTest()) { app.initDoneSuccesfully = false; return false; }
                app.ls3dCompressorParams = GetCompressorPaths(app.C_SELECTED_COMPRESSOR_INDEX);
                if (app.ls3dCompressorParams == null) { app.initDoneSuccesfully = false; return false; }
            }
            LoadCustomAttribs();
            log("Sorting Formats and MapTypes.", 1, 3);
            if (!SortFormatsAndMapTypes() || app.ls3DCustomData.version != C_SCRIPT_VERSION)
            {   
                log("Formats and MapTypes were different. Saving new CustomAttributes.", 2, 2);
                SaveCustomAttribs();
            }
            if (showGUI) ShowGUI(true);
            else { if (CustomAttribsExist()) { SaveCustomAttribs(); } }
        } catch (e) {
            log("Error in Init(" + showGUI + ", " + builderExport + ") = \n" + e, 3, 1);
            app.initDoneSuccesfully = false;
        }/**/
        if (app.EXTERNAL_OBJECT != null) app.EXTERNAL_OBJECT.unload();
    
        log("END: Init(" + showGUI + ", " + builderExport + ")", 1, 3);
        return app.initDoneSuccesfully;    }
}
//--------- /END INIT --------------------------------------------------------------------------------------------------------------------------------------------------------

